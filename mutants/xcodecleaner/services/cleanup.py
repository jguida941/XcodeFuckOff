"""
Cleanup services for XcodeCleaner.

All external commands go through CommandRunner for testability.
"""
from __future__ import annotations

from dataclasses import dataclass
import glob
import json
import os
import re
import shlex
from typing import Dict, Iterable, List, Mapping, Optional, Sequence, Tuple

from xcodecleaner.core.runner import CmdResult, CommandRunner, get_default_runner
from xcodecleaner.services import processes as svc_processes
from xcodecleaner.services import space as svc_space
from xcodecleaner.system import devtools as svc_devtools


DENIED_MARKERS = ("operation not permitted", "permission denied")
NOT_MOUNTED_MARKERS = ("not mounted", "not currently mounted", "not a mount point")

RUNTIME_GLOBS = (
	"/Library/Developer/CoreSimulator/Volumes/iOS_*",
	"/Library/Developer/CoreSimulator/Volumes/tvOS_*",
	"/Library/Developer/CoreSimulator/Volumes/watchOS_*",
	"/Library/Developer/CoreSimulator/Volumes/xrOS_*",
)
CRYP_TEX_PATH = "/Library/Developer/CoreSimulator/Cryptex"
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
	"""Forward call to original or mutated function, depending on the environment"""
	import os
	mutant_under_test = os.environ['MUTANT_UNDER_TEST']
	if mutant_under_test == 'fail':
		from mutmut.__main__ import MutmutProgrammaticFailException
		raise MutmutProgrammaticFailException('Failed programmatically')      
	elif mutant_under_test == 'stats':
		from mutmut.__main__ import record_trampoline_hit
		record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
		result = orig(*call_args, **call_kwargs)
		return result
	prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
	if not mutant_under_test.startswith(prefix):
		result = orig(*call_args, **call_kwargs)
		return result
	mutant_name = mutant_under_test.rpartition('.')[-1]
	if self_arg is not None:
		# call to a class method where self is not bound
		result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
	else:
		result = mutants[mutant_name](*call_args, **call_kwargs)
	return result


@dataclass(frozen=True)
class StepResult:
	label: str
	result: CmdResult
	required: bool = True
	sudo: bool = False
	allow_not_mounted: bool = False

	@property
	def ok(self) -> bool:
		if self.result.timed_out:
			return False
		if _is_denied(self.result):
			return False
		if self.result.returncode == 0:
			return True
		if self.allow_not_mounted and _is_not_mounted(self.result):
			return True
		return False


@dataclass(frozen=True)
class ActionResult:
	commands_ok: bool
	steps: List[StepResult]
	error: Optional[str] = None


@dataclass(frozen=True)
class CleanupResult:
	commands_ok: bool
	space_before: Optional[int]
	space_after: Optional[int]
	space_delta: Optional[int]
	space_ok: Optional[bool]
	steps: List[StepResult]
	error: Optional[str] = None


@dataclass(frozen=True)
class RuntimeInfo:
	identifier: str
	name: str
	version: str
	build: str
	state: str
	size_bytes: int


def x__is_denied__mutmut_orig(result: CmdResult) -> bool:
	message = f"{result.stderr} {result.stdout}".lower()
	return any(marker in message for marker in DENIED_MARKERS)


def x__is_denied__mutmut_1(result: CmdResult) -> bool:
	message = None
	return any(marker in message for marker in DENIED_MARKERS)


def x__is_denied__mutmut_2(result: CmdResult) -> bool:
	message = f"{result.stderr} {result.stdout}".upper()
	return any(marker in message for marker in DENIED_MARKERS)


def x__is_denied__mutmut_3(result: CmdResult) -> bool:
	message = f"{result.stderr} {result.stdout}".lower()
	return any(None)


def x__is_denied__mutmut_4(result: CmdResult) -> bool:
	message = f"{result.stderr} {result.stdout}".lower()
	return any(marker not in message for marker in DENIED_MARKERS)

x__is_denied__mutmut_mutants : ClassVar[MutantDict] = {
'x__is_denied__mutmut_1': x__is_denied__mutmut_1, 
    'x__is_denied__mutmut_2': x__is_denied__mutmut_2, 
    'x__is_denied__mutmut_3': x__is_denied__mutmut_3, 
    'x__is_denied__mutmut_4': x__is_denied__mutmut_4
}

def _is_denied(*args, **kwargs):
	result = _mutmut_trampoline(x__is_denied__mutmut_orig, x__is_denied__mutmut_mutants, args, kwargs)
	return result 

_is_denied.__signature__ = _mutmut_signature(x__is_denied__mutmut_orig)
x__is_denied__mutmut_orig.__name__ = 'x__is_denied'


def x__is_not_mounted__mutmut_orig(result: CmdResult) -> bool:
	message = f"{result.stderr} {result.stdout}".lower()
	return any(marker in message for marker in NOT_MOUNTED_MARKERS)


def x__is_not_mounted__mutmut_1(result: CmdResult) -> bool:
	message = None
	return any(marker in message for marker in NOT_MOUNTED_MARKERS)


def x__is_not_mounted__mutmut_2(result: CmdResult) -> bool:
	message = f"{result.stderr} {result.stdout}".upper()
	return any(marker in message for marker in NOT_MOUNTED_MARKERS)


def x__is_not_mounted__mutmut_3(result: CmdResult) -> bool:
	message = f"{result.stderr} {result.stdout}".lower()
	return any(None)


def x__is_not_mounted__mutmut_4(result: CmdResult) -> bool:
	message = f"{result.stderr} {result.stdout}".lower()
	return any(marker not in message for marker in NOT_MOUNTED_MARKERS)

x__is_not_mounted__mutmut_mutants : ClassVar[MutantDict] = {
'x__is_not_mounted__mutmut_1': x__is_not_mounted__mutmut_1, 
    'x__is_not_mounted__mutmut_2': x__is_not_mounted__mutmut_2, 
    'x__is_not_mounted__mutmut_3': x__is_not_mounted__mutmut_3, 
    'x__is_not_mounted__mutmut_4': x__is_not_mounted__mutmut_4
}

def _is_not_mounted(*args, **kwargs):
	result = _mutmut_trampoline(x__is_not_mounted__mutmut_orig, x__is_not_mounted__mutmut_mutants, args, kwargs)
	return result 

_is_not_mounted.__signature__ = _mutmut_signature(x__is_not_mounted__mutmut_orig)
x__is_not_mounted__mutmut_orig.__name__ = 'x__is_not_mounted'


def x__first_required_error__mutmut_orig(steps: Iterable[StepResult]) -> Optional[str]:
	for step in steps:
		if step.required and not step.ok:
			return step.result.stderr.strip() or step.result.stdout.strip() or f"{step.label} failed"
	return None


def x__first_required_error__mutmut_1(steps: Iterable[StepResult]) -> Optional[str]:
	for step in steps:
		if step.required or not step.ok:
			return step.result.stderr.strip() or step.result.stdout.strip() or f"{step.label} failed"
	return None


def x__first_required_error__mutmut_2(steps: Iterable[StepResult]) -> Optional[str]:
	for step in steps:
		if step.required and step.ok:
			return step.result.stderr.strip() or step.result.stdout.strip() or f"{step.label} failed"
	return None


def x__first_required_error__mutmut_3(steps: Iterable[StepResult]) -> Optional[str]:
	for step in steps:
		if step.required and not step.ok:
			return step.result.stderr.strip() or step.result.stdout.strip() and f"{step.label} failed"
	return None


def x__first_required_error__mutmut_4(steps: Iterable[StepResult]) -> Optional[str]:
	for step in steps:
		if step.required and not step.ok:
			return step.result.stderr.strip() and step.result.stdout.strip() or f"{step.label} failed"
	return None

x__first_required_error__mutmut_mutants : ClassVar[MutantDict] = {
'x__first_required_error__mutmut_1': x__first_required_error__mutmut_1, 
    'x__first_required_error__mutmut_2': x__first_required_error__mutmut_2, 
    'x__first_required_error__mutmut_3': x__first_required_error__mutmut_3, 
    'x__first_required_error__mutmut_4': x__first_required_error__mutmut_4
}

def _first_required_error(*args, **kwargs):
	result = _mutmut_trampoline(x__first_required_error__mutmut_orig, x__first_required_error__mutmut_mutants, args, kwargs)
	return result 

_first_required_error.__signature__ = _mutmut_signature(x__first_required_error__mutmut_orig)
x__first_required_error__mutmut_orig.__name__ = 'x__first_required_error'


def x__commands_ok__mutmut_orig(steps: Iterable[StepResult]) -> bool:
	return all(step.ok for step in steps if step.required)


def x__commands_ok__mutmut_1(steps: Iterable[StepResult]) -> bool:
	return all(None)

x__commands_ok__mutmut_mutants : ClassVar[MutantDict] = {
'x__commands_ok__mutmut_1': x__commands_ok__mutmut_1
}

def _commands_ok(*args, **kwargs):
	result = _mutmut_trampoline(x__commands_ok__mutmut_orig, x__commands_ok__mutmut_mutants, args, kwargs)
	return result 

_commands_ok.__signature__ = _mutmut_signature(x__commands_ok__mutmut_orig)
x__commands_ok__mutmut_orig.__name__ = 'x__commands_ok'


def x__parse_simctl_runtimes__mutmut_orig(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_1(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload or isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_2(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "XXruntimesXX" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_3(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "RUNTIMES" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_4(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" not in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_5(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = None
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_6(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["XXruntimesXX"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_7(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["RUNTIMES"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_8(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload or isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_9(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "XXRuntimesXX" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_10(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_11(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "RUNTIMES" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_12(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" not in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_13(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = None
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_14(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["XXRuntimesXX"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_15(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_16(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["RUNTIMES"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_17(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = None
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_18(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = None
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_19(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(None)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_20(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = None
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_21(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["XXidentifierXX"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_22(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["IDENTIFIER"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_23(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get(None, runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_24(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", None)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_25(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get(runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_26(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", )
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_27(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("XXidentifierXX", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_28(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("IDENTIFIER", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_29(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(None)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_30(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = None
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_31(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = None

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_32(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = None
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_33(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_34(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			break
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_35(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = None
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_36(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") and ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_37(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") and info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_38(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get(None) or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_39(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("XXidentifierXX") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_40(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("IDENTIFIER") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_41(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get(None) or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_42(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("XXidXX") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_43(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("ID") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_44(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or "XXXX"
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_45(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_46(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			break
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_47(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = None
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_48(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get(None, "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_49(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", None)
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_50(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_51(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", )
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_52(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("XXnameXX", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_53(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("NAME", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_54(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "XXUnknownXX")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_55(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_56(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "UNKNOWN")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_57(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = None
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_58(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get(None, "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_59(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", None)
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_60(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_61(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", )
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_62(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("XXversionXX", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_63(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("VERSION", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_64(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "XXXX")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_65(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = None
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_66(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") and ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_67(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") and info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_68(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get(None) or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_69(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("XXbuildXX") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_70(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("BUILD") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_71(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get(None, "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_72(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", None) or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_73(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_74(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", ) or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_75(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("XXbuildversionXX", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_76(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("BUILDVERSION", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_77(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "XXXX") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_78(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or "XXXX"
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_79(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = None
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_80(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get(None, "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_81(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", None)
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_82(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_83(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", )
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_84(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("XXstateXX", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_85(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("STATE", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_86(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "XXXX")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_87(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = None
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_88(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(None)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_89(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") and 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_90(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") and info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_91(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get(None) or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_92(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("XXsizeBytesXX") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_93(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizebytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_94(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("SIZEBYTES") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_95(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get(None) or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_96(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("XXbundleSizeXX") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_97(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundlesize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_98(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("BUNDLESIZE") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_99(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 1)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_100(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			None
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_101(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=None,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_102(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=None,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_103(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=None,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_104(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=None,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_105(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=None,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_106(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=None,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_107(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				name=name,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_108(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				version=version,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_109(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				build=build,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_110(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				state=state,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_111(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				size_bytes=size_bytes,
			)
		)
	return runtimes


def x__parse_simctl_runtimes__mutmut_112(payload: object) -> List[RuntimeInfo]:
	if isinstance(payload, dict):
		if "runtimes" in payload and isinstance(payload["runtimes"], list):
			entries = payload["runtimes"]
		elif "Runtimes" in payload and isinstance(payload["Runtimes"], list):
			entries = payload["Runtimes"]
		else:
			entries = []
			for runtime_id, info in payload.items():
				if isinstance(info, dict):
					info = dict(info)
					info["identifier"] = info.get("identifier", runtime_id)
					entries.append(info)
	elif isinstance(payload, list):
		entries = payload
	else:
		entries = []

	runtimes: List[RuntimeInfo] = []
	for info in entries:
		if not isinstance(info, dict):
			continue
		identifier = info.get("identifier") or info.get("id") or ""
		if not identifier:
			continue
		name = info.get("name", "Unknown")
		version = info.get("version", "")
		build = info.get("build") or info.get("buildversion", "") or ""
		state = info.get("state", "")
		size_bytes = int(info.get("sizeBytes") or info.get("bundleSize") or 0)
		runtimes.append(
			RuntimeInfo(
				identifier=identifier,
				name=name,
				version=version,
				build=build,
				state=state,
				)
		)
	return runtimes

x__parse_simctl_runtimes__mutmut_mutants : ClassVar[MutantDict] = {
'x__parse_simctl_runtimes__mutmut_1': x__parse_simctl_runtimes__mutmut_1, 
    'x__parse_simctl_runtimes__mutmut_2': x__parse_simctl_runtimes__mutmut_2, 
    'x__parse_simctl_runtimes__mutmut_3': x__parse_simctl_runtimes__mutmut_3, 
    'x__parse_simctl_runtimes__mutmut_4': x__parse_simctl_runtimes__mutmut_4, 
    'x__parse_simctl_runtimes__mutmut_5': x__parse_simctl_runtimes__mutmut_5, 
    'x__parse_simctl_runtimes__mutmut_6': x__parse_simctl_runtimes__mutmut_6, 
    'x__parse_simctl_runtimes__mutmut_7': x__parse_simctl_runtimes__mutmut_7, 
    'x__parse_simctl_runtimes__mutmut_8': x__parse_simctl_runtimes__mutmut_8, 
    'x__parse_simctl_runtimes__mutmut_9': x__parse_simctl_runtimes__mutmut_9, 
    'x__parse_simctl_runtimes__mutmut_10': x__parse_simctl_runtimes__mutmut_10, 
    'x__parse_simctl_runtimes__mutmut_11': x__parse_simctl_runtimes__mutmut_11, 
    'x__parse_simctl_runtimes__mutmut_12': x__parse_simctl_runtimes__mutmut_12, 
    'x__parse_simctl_runtimes__mutmut_13': x__parse_simctl_runtimes__mutmut_13, 
    'x__parse_simctl_runtimes__mutmut_14': x__parse_simctl_runtimes__mutmut_14, 
    'x__parse_simctl_runtimes__mutmut_15': x__parse_simctl_runtimes__mutmut_15, 
    'x__parse_simctl_runtimes__mutmut_16': x__parse_simctl_runtimes__mutmut_16, 
    'x__parse_simctl_runtimes__mutmut_17': x__parse_simctl_runtimes__mutmut_17, 
    'x__parse_simctl_runtimes__mutmut_18': x__parse_simctl_runtimes__mutmut_18, 
    'x__parse_simctl_runtimes__mutmut_19': x__parse_simctl_runtimes__mutmut_19, 
    'x__parse_simctl_runtimes__mutmut_20': x__parse_simctl_runtimes__mutmut_20, 
    'x__parse_simctl_runtimes__mutmut_21': x__parse_simctl_runtimes__mutmut_21, 
    'x__parse_simctl_runtimes__mutmut_22': x__parse_simctl_runtimes__mutmut_22, 
    'x__parse_simctl_runtimes__mutmut_23': x__parse_simctl_runtimes__mutmut_23, 
    'x__parse_simctl_runtimes__mutmut_24': x__parse_simctl_runtimes__mutmut_24, 
    'x__parse_simctl_runtimes__mutmut_25': x__parse_simctl_runtimes__mutmut_25, 
    'x__parse_simctl_runtimes__mutmut_26': x__parse_simctl_runtimes__mutmut_26, 
    'x__parse_simctl_runtimes__mutmut_27': x__parse_simctl_runtimes__mutmut_27, 
    'x__parse_simctl_runtimes__mutmut_28': x__parse_simctl_runtimes__mutmut_28, 
    'x__parse_simctl_runtimes__mutmut_29': x__parse_simctl_runtimes__mutmut_29, 
    'x__parse_simctl_runtimes__mutmut_30': x__parse_simctl_runtimes__mutmut_30, 
    'x__parse_simctl_runtimes__mutmut_31': x__parse_simctl_runtimes__mutmut_31, 
    'x__parse_simctl_runtimes__mutmut_32': x__parse_simctl_runtimes__mutmut_32, 
    'x__parse_simctl_runtimes__mutmut_33': x__parse_simctl_runtimes__mutmut_33, 
    'x__parse_simctl_runtimes__mutmut_34': x__parse_simctl_runtimes__mutmut_34, 
    'x__parse_simctl_runtimes__mutmut_35': x__parse_simctl_runtimes__mutmut_35, 
    'x__parse_simctl_runtimes__mutmut_36': x__parse_simctl_runtimes__mutmut_36, 
    'x__parse_simctl_runtimes__mutmut_37': x__parse_simctl_runtimes__mutmut_37, 
    'x__parse_simctl_runtimes__mutmut_38': x__parse_simctl_runtimes__mutmut_38, 
    'x__parse_simctl_runtimes__mutmut_39': x__parse_simctl_runtimes__mutmut_39, 
    'x__parse_simctl_runtimes__mutmut_40': x__parse_simctl_runtimes__mutmut_40, 
    'x__parse_simctl_runtimes__mutmut_41': x__parse_simctl_runtimes__mutmut_41, 
    'x__parse_simctl_runtimes__mutmut_42': x__parse_simctl_runtimes__mutmut_42, 
    'x__parse_simctl_runtimes__mutmut_43': x__parse_simctl_runtimes__mutmut_43, 
    'x__parse_simctl_runtimes__mutmut_44': x__parse_simctl_runtimes__mutmut_44, 
    'x__parse_simctl_runtimes__mutmut_45': x__parse_simctl_runtimes__mutmut_45, 
    'x__parse_simctl_runtimes__mutmut_46': x__parse_simctl_runtimes__mutmut_46, 
    'x__parse_simctl_runtimes__mutmut_47': x__parse_simctl_runtimes__mutmut_47, 
    'x__parse_simctl_runtimes__mutmut_48': x__parse_simctl_runtimes__mutmut_48, 
    'x__parse_simctl_runtimes__mutmut_49': x__parse_simctl_runtimes__mutmut_49, 
    'x__parse_simctl_runtimes__mutmut_50': x__parse_simctl_runtimes__mutmut_50, 
    'x__parse_simctl_runtimes__mutmut_51': x__parse_simctl_runtimes__mutmut_51, 
    'x__parse_simctl_runtimes__mutmut_52': x__parse_simctl_runtimes__mutmut_52, 
    'x__parse_simctl_runtimes__mutmut_53': x__parse_simctl_runtimes__mutmut_53, 
    'x__parse_simctl_runtimes__mutmut_54': x__parse_simctl_runtimes__mutmut_54, 
    'x__parse_simctl_runtimes__mutmut_55': x__parse_simctl_runtimes__mutmut_55, 
    'x__parse_simctl_runtimes__mutmut_56': x__parse_simctl_runtimes__mutmut_56, 
    'x__parse_simctl_runtimes__mutmut_57': x__parse_simctl_runtimes__mutmut_57, 
    'x__parse_simctl_runtimes__mutmut_58': x__parse_simctl_runtimes__mutmut_58, 
    'x__parse_simctl_runtimes__mutmut_59': x__parse_simctl_runtimes__mutmut_59, 
    'x__parse_simctl_runtimes__mutmut_60': x__parse_simctl_runtimes__mutmut_60, 
    'x__parse_simctl_runtimes__mutmut_61': x__parse_simctl_runtimes__mutmut_61, 
    'x__parse_simctl_runtimes__mutmut_62': x__parse_simctl_runtimes__mutmut_62, 
    'x__parse_simctl_runtimes__mutmut_63': x__parse_simctl_runtimes__mutmut_63, 
    'x__parse_simctl_runtimes__mutmut_64': x__parse_simctl_runtimes__mutmut_64, 
    'x__parse_simctl_runtimes__mutmut_65': x__parse_simctl_runtimes__mutmut_65, 
    'x__parse_simctl_runtimes__mutmut_66': x__parse_simctl_runtimes__mutmut_66, 
    'x__parse_simctl_runtimes__mutmut_67': x__parse_simctl_runtimes__mutmut_67, 
    'x__parse_simctl_runtimes__mutmut_68': x__parse_simctl_runtimes__mutmut_68, 
    'x__parse_simctl_runtimes__mutmut_69': x__parse_simctl_runtimes__mutmut_69, 
    'x__parse_simctl_runtimes__mutmut_70': x__parse_simctl_runtimes__mutmut_70, 
    'x__parse_simctl_runtimes__mutmut_71': x__parse_simctl_runtimes__mutmut_71, 
    'x__parse_simctl_runtimes__mutmut_72': x__parse_simctl_runtimes__mutmut_72, 
    'x__parse_simctl_runtimes__mutmut_73': x__parse_simctl_runtimes__mutmut_73, 
    'x__parse_simctl_runtimes__mutmut_74': x__parse_simctl_runtimes__mutmut_74, 
    'x__parse_simctl_runtimes__mutmut_75': x__parse_simctl_runtimes__mutmut_75, 
    'x__parse_simctl_runtimes__mutmut_76': x__parse_simctl_runtimes__mutmut_76, 
    'x__parse_simctl_runtimes__mutmut_77': x__parse_simctl_runtimes__mutmut_77, 
    'x__parse_simctl_runtimes__mutmut_78': x__parse_simctl_runtimes__mutmut_78, 
    'x__parse_simctl_runtimes__mutmut_79': x__parse_simctl_runtimes__mutmut_79, 
    'x__parse_simctl_runtimes__mutmut_80': x__parse_simctl_runtimes__mutmut_80, 
    'x__parse_simctl_runtimes__mutmut_81': x__parse_simctl_runtimes__mutmut_81, 
    'x__parse_simctl_runtimes__mutmut_82': x__parse_simctl_runtimes__mutmut_82, 
    'x__parse_simctl_runtimes__mutmut_83': x__parse_simctl_runtimes__mutmut_83, 
    'x__parse_simctl_runtimes__mutmut_84': x__parse_simctl_runtimes__mutmut_84, 
    'x__parse_simctl_runtimes__mutmut_85': x__parse_simctl_runtimes__mutmut_85, 
    'x__parse_simctl_runtimes__mutmut_86': x__parse_simctl_runtimes__mutmut_86, 
    'x__parse_simctl_runtimes__mutmut_87': x__parse_simctl_runtimes__mutmut_87, 
    'x__parse_simctl_runtimes__mutmut_88': x__parse_simctl_runtimes__mutmut_88, 
    'x__parse_simctl_runtimes__mutmut_89': x__parse_simctl_runtimes__mutmut_89, 
    'x__parse_simctl_runtimes__mutmut_90': x__parse_simctl_runtimes__mutmut_90, 
    'x__parse_simctl_runtimes__mutmut_91': x__parse_simctl_runtimes__mutmut_91, 
    'x__parse_simctl_runtimes__mutmut_92': x__parse_simctl_runtimes__mutmut_92, 
    'x__parse_simctl_runtimes__mutmut_93': x__parse_simctl_runtimes__mutmut_93, 
    'x__parse_simctl_runtimes__mutmut_94': x__parse_simctl_runtimes__mutmut_94, 
    'x__parse_simctl_runtimes__mutmut_95': x__parse_simctl_runtimes__mutmut_95, 
    'x__parse_simctl_runtimes__mutmut_96': x__parse_simctl_runtimes__mutmut_96, 
    'x__parse_simctl_runtimes__mutmut_97': x__parse_simctl_runtimes__mutmut_97, 
    'x__parse_simctl_runtimes__mutmut_98': x__parse_simctl_runtimes__mutmut_98, 
    'x__parse_simctl_runtimes__mutmut_99': x__parse_simctl_runtimes__mutmut_99, 
    'x__parse_simctl_runtimes__mutmut_100': x__parse_simctl_runtimes__mutmut_100, 
    'x__parse_simctl_runtimes__mutmut_101': x__parse_simctl_runtimes__mutmut_101, 
    'x__parse_simctl_runtimes__mutmut_102': x__parse_simctl_runtimes__mutmut_102, 
    'x__parse_simctl_runtimes__mutmut_103': x__parse_simctl_runtimes__mutmut_103, 
    'x__parse_simctl_runtimes__mutmut_104': x__parse_simctl_runtimes__mutmut_104, 
    'x__parse_simctl_runtimes__mutmut_105': x__parse_simctl_runtimes__mutmut_105, 
    'x__parse_simctl_runtimes__mutmut_106': x__parse_simctl_runtimes__mutmut_106, 
    'x__parse_simctl_runtimes__mutmut_107': x__parse_simctl_runtimes__mutmut_107, 
    'x__parse_simctl_runtimes__mutmut_108': x__parse_simctl_runtimes__mutmut_108, 
    'x__parse_simctl_runtimes__mutmut_109': x__parse_simctl_runtimes__mutmut_109, 
    'x__parse_simctl_runtimes__mutmut_110': x__parse_simctl_runtimes__mutmut_110, 
    'x__parse_simctl_runtimes__mutmut_111': x__parse_simctl_runtimes__mutmut_111, 
    'x__parse_simctl_runtimes__mutmut_112': x__parse_simctl_runtimes__mutmut_112
}

def _parse_simctl_runtimes(*args, **kwargs):
	result = _mutmut_trampoline(x__parse_simctl_runtimes__mutmut_orig, x__parse_simctl_runtimes__mutmut_mutants, args, kwargs)
	return result 

_parse_simctl_runtimes.__signature__ = _mutmut_signature(x__parse_simctl_runtimes__mutmut_orig)
x__parse_simctl_runtimes__mutmut_orig.__name__ = 'x__parse_simctl_runtimes'


def x_parse_simctl_runtime_list__mutmut_orig(text: str) -> Tuple[List[RuntimeInfo], Optional[str]]:
	try:
		payload = json.loads(text)
	except Exception as exc:
		return [], f"Failed to parse simctl runtime list: {exc}"
	return _parse_simctl_runtimes(payload), None


def x_parse_simctl_runtime_list__mutmut_1(text: str) -> Tuple[List[RuntimeInfo], Optional[str]]:
	try:
		payload = None
	except Exception as exc:
		return [], f"Failed to parse simctl runtime list: {exc}"
	return _parse_simctl_runtimes(payload), None


def x_parse_simctl_runtime_list__mutmut_2(text: str) -> Tuple[List[RuntimeInfo], Optional[str]]:
	try:
		payload = json.loads(None)
	except Exception as exc:
		return [], f"Failed to parse simctl runtime list: {exc}"
	return _parse_simctl_runtimes(payload), None


def x_parse_simctl_runtime_list__mutmut_3(text: str) -> Tuple[List[RuntimeInfo], Optional[str]]:
	try:
		payload = json.loads(text)
	except Exception as exc:
		return [], f"Failed to parse simctl runtime list: {exc}"
	return _parse_simctl_runtimes(None), None

x_parse_simctl_runtime_list__mutmut_mutants : ClassVar[MutantDict] = {
'x_parse_simctl_runtime_list__mutmut_1': x_parse_simctl_runtime_list__mutmut_1, 
    'x_parse_simctl_runtime_list__mutmut_2': x_parse_simctl_runtime_list__mutmut_2, 
    'x_parse_simctl_runtime_list__mutmut_3': x_parse_simctl_runtime_list__mutmut_3
}

def parse_simctl_runtime_list(*args, **kwargs):
	result = _mutmut_trampoline(x_parse_simctl_runtime_list__mutmut_orig, x_parse_simctl_runtime_list__mutmut_mutants, args, kwargs)
	return result 

parse_simctl_runtime_list.__signature__ = _mutmut_signature(x_parse_simctl_runtime_list__mutmut_orig)
x_parse_simctl_runtime_list__mutmut_orig.__name__ = 'x_parse_simctl_runtime_list'


class CleanupService:
	def xCleanupService__init____mutmut_orig(self, runner: CommandRunner | None = None, simctl_env: Mapping[str, str] | None = None):
		self._runner = runner or get_default_runner()
		self._simctl_env = dict(simctl_env) if simctl_env else None
	def xCleanupService__init____mutmut_1(self, runner: CommandRunner | None = None, simctl_env: Mapping[str, str] | None = None):
		self._runner = None
		self._simctl_env = dict(simctl_env) if simctl_env else None
	def xCleanupService__init____mutmut_2(self, runner: CommandRunner | None = None, simctl_env: Mapping[str, str] | None = None):
		self._runner = runner and get_default_runner()
		self._simctl_env = dict(simctl_env) if simctl_env else None
	def xCleanupService__init____mutmut_3(self, runner: CommandRunner | None = None, simctl_env: Mapping[str, str] | None = None):
		self._runner = runner or get_default_runner()
		self._simctl_env = None
	def xCleanupService__init____mutmut_4(self, runner: CommandRunner | None = None, simctl_env: Mapping[str, str] | None = None):
		self._runner = runner or get_default_runner()
		self._simctl_env = dict(None) if simctl_env else None
	
	xCleanupService__init____mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupService__init____mutmut_1': xCleanupService__init____mutmut_1, 
	    'xCleanupService__init____mutmut_2': xCleanupService__init____mutmut_2, 
	    'xCleanupService__init____mutmut_3': xCleanupService__init____mutmut_3, 
	    'xCleanupService__init____mutmut_4': xCleanupService__init____mutmut_4
	}
	
	def __init__(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupService__init____mutmut_orig"), object.__getattribute__(self, "xCleanupService__init____mutmut_mutants"), args, kwargs, self)
		return result 
	
	__init__.__signature__ = _mutmut_signature(xCleanupService__init____mutmut_orig)
	xCleanupService__init____mutmut_orig.__name__ = 'xCleanupService__init__'

	def xCleanupService_run_step__mutmut_orig(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, timeout=timeout, text=text, env=env)
		return StepResult(
			label=label,
			result=result,
			required=required,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_1(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = True,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, timeout=timeout, text=text, env=env)
		return StepResult(
			label=label,
			result=result,
			required=required,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_2(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = False,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, timeout=timeout, text=text, env=env)
		return StepResult(
			label=label,
			result=result,
			required=required,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_3(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = True,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, timeout=timeout, text=text, env=env)
		return StepResult(
			label=label,
			result=result,
			required=required,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_4(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = False,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, timeout=timeout, text=text, env=env)
		return StepResult(
			label=label,
			result=result,
			required=required,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_5(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = None
		return StepResult(
			label=label,
			result=result,
			required=required,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_6(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(None, sudo=sudo, timeout=timeout, text=text, env=env)
		return StepResult(
			label=label,
			result=result,
			required=required,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_7(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=None, timeout=timeout, text=text, env=env)
		return StepResult(
			label=label,
			result=result,
			required=required,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_8(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, timeout=None, text=text, env=env)
		return StepResult(
			label=label,
			result=result,
			required=required,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_9(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, timeout=timeout, text=None, env=env)
		return StepResult(
			label=label,
			result=result,
			required=required,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_10(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, timeout=timeout, text=text, env=None)
		return StepResult(
			label=label,
			result=result,
			required=required,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_11(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(sudo=sudo, timeout=timeout, text=text, env=env)
		return StepResult(
			label=label,
			result=result,
			required=required,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_12(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, timeout=timeout, text=text, env=env)
		return StepResult(
			label=label,
			result=result,
			required=required,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_13(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, text=text, env=env)
		return StepResult(
			label=label,
			result=result,
			required=required,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_14(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, timeout=timeout, env=env)
		return StepResult(
			label=label,
			result=result,
			required=required,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_15(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, timeout=timeout, text=text, )
		return StepResult(
			label=label,
			result=result,
			required=required,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_16(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, timeout=timeout, text=text, env=env)
		return StepResult(
			label=None,
			result=result,
			required=required,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_17(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, timeout=timeout, text=text, env=env)
		return StepResult(
			label=label,
			result=None,
			required=required,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_18(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, timeout=timeout, text=text, env=env)
		return StepResult(
			label=label,
			result=result,
			required=None,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_19(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, timeout=timeout, text=text, env=env)
		return StepResult(
			label=label,
			result=result,
			required=required,
			sudo=None,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_20(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, timeout=timeout, text=text, env=env)
		return StepResult(
			label=label,
			result=result,
			required=required,
			sudo=sudo,
			allow_not_mounted=None,
		)

	def xCleanupService_run_step__mutmut_21(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, timeout=timeout, text=text, env=env)
		return StepResult(
			result=result,
			required=required,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_22(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, timeout=timeout, text=text, env=env)
		return StepResult(
			label=label,
			required=required,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_23(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, timeout=timeout, text=text, env=env)
		return StepResult(
			label=label,
			result=result,
			sudo=sudo,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_24(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, timeout=timeout, text=text, env=env)
		return StepResult(
			label=label,
			result=result,
			required=required,
			allow_not_mounted=allow_not_mounted,
		)

	def xCleanupService_run_step__mutmut_25(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		sudo: bool = False,
		timeout: int | None = None,
		required: bool = True,
		allow_not_mounted: bool = False,
		text: bool = True,
		env: Mapping[str, str] | None = None,
	) -> StepResult:
		result = self._runner.run(cmd, sudo=sudo, timeout=timeout, text=text, env=env)
		return StepResult(
			label=label,
			result=result,
			required=required,
			sudo=sudo,
			)
	
	xCleanupService_run_step__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupService_run_step__mutmut_1': xCleanupService_run_step__mutmut_1, 
	    'xCleanupService_run_step__mutmut_2': xCleanupService_run_step__mutmut_2, 
	    'xCleanupService_run_step__mutmut_3': xCleanupService_run_step__mutmut_3, 
	    'xCleanupService_run_step__mutmut_4': xCleanupService_run_step__mutmut_4, 
	    'xCleanupService_run_step__mutmut_5': xCleanupService_run_step__mutmut_5, 
	    'xCleanupService_run_step__mutmut_6': xCleanupService_run_step__mutmut_6, 
	    'xCleanupService_run_step__mutmut_7': xCleanupService_run_step__mutmut_7, 
	    'xCleanupService_run_step__mutmut_8': xCleanupService_run_step__mutmut_8, 
	    'xCleanupService_run_step__mutmut_9': xCleanupService_run_step__mutmut_9, 
	    'xCleanupService_run_step__mutmut_10': xCleanupService_run_step__mutmut_10, 
	    'xCleanupService_run_step__mutmut_11': xCleanupService_run_step__mutmut_11, 
	    'xCleanupService_run_step__mutmut_12': xCleanupService_run_step__mutmut_12, 
	    'xCleanupService_run_step__mutmut_13': xCleanupService_run_step__mutmut_13, 
	    'xCleanupService_run_step__mutmut_14': xCleanupService_run_step__mutmut_14, 
	    'xCleanupService_run_step__mutmut_15': xCleanupService_run_step__mutmut_15, 
	    'xCleanupService_run_step__mutmut_16': xCleanupService_run_step__mutmut_16, 
	    'xCleanupService_run_step__mutmut_17': xCleanupService_run_step__mutmut_17, 
	    'xCleanupService_run_step__mutmut_18': xCleanupService_run_step__mutmut_18, 
	    'xCleanupService_run_step__mutmut_19': xCleanupService_run_step__mutmut_19, 
	    'xCleanupService_run_step__mutmut_20': xCleanupService_run_step__mutmut_20, 
	    'xCleanupService_run_step__mutmut_21': xCleanupService_run_step__mutmut_21, 
	    'xCleanupService_run_step__mutmut_22': xCleanupService_run_step__mutmut_22, 
	    'xCleanupService_run_step__mutmut_23': xCleanupService_run_step__mutmut_23, 
	    'xCleanupService_run_step__mutmut_24': xCleanupService_run_step__mutmut_24, 
	    'xCleanupService_run_step__mutmut_25': xCleanupService_run_step__mutmut_25
	}
	
	def _run_step(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupService_run_step__mutmut_orig"), object.__getattribute__(self, "xCleanupService_run_step__mutmut_mutants"), args, kwargs, self)
		return result 
	
	_run_step.__signature__ = _mutmut_signature(xCleanupService_run_step__mutmut_orig)
	xCleanupService_run_step__mutmut_orig.__name__ = 'xCleanupService_run_step'

	def xCleanupService_run_simctl_step__mutmut_orig(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		required: bool = True,
		timeout: int | None = None,
	) -> StepResult:
		return self._run_step(label, cmd, required=required, timeout=timeout, env=self._simctl_env)

	def xCleanupService_run_simctl_step__mutmut_1(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		required: bool = False,
		timeout: int | None = None,
	) -> StepResult:
		return self._run_step(label, cmd, required=required, timeout=timeout, env=self._simctl_env)

	def xCleanupService_run_simctl_step__mutmut_2(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		required: bool = True,
		timeout: int | None = None,
	) -> StepResult:
		return self._run_step(None, cmd, required=required, timeout=timeout, env=self._simctl_env)

	def xCleanupService_run_simctl_step__mutmut_3(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		required: bool = True,
		timeout: int | None = None,
	) -> StepResult:
		return self._run_step(label, None, required=required, timeout=timeout, env=self._simctl_env)

	def xCleanupService_run_simctl_step__mutmut_4(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		required: bool = True,
		timeout: int | None = None,
	) -> StepResult:
		return self._run_step(label, cmd, required=None, timeout=timeout, env=self._simctl_env)

	def xCleanupService_run_simctl_step__mutmut_5(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		required: bool = True,
		timeout: int | None = None,
	) -> StepResult:
		return self._run_step(label, cmd, required=required, timeout=None, env=self._simctl_env)

	def xCleanupService_run_simctl_step__mutmut_6(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		required: bool = True,
		timeout: int | None = None,
	) -> StepResult:
		return self._run_step(label, cmd, required=required, timeout=timeout, env=None)

	def xCleanupService_run_simctl_step__mutmut_7(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		required: bool = True,
		timeout: int | None = None,
	) -> StepResult:
		return self._run_step(cmd, required=required, timeout=timeout, env=self._simctl_env)

	def xCleanupService_run_simctl_step__mutmut_8(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		required: bool = True,
		timeout: int | None = None,
	) -> StepResult:
		return self._run_step(label, required=required, timeout=timeout, env=self._simctl_env)

	def xCleanupService_run_simctl_step__mutmut_9(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		required: bool = True,
		timeout: int | None = None,
	) -> StepResult:
		return self._run_step(label, cmd, timeout=timeout, env=self._simctl_env)

	def xCleanupService_run_simctl_step__mutmut_10(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		required: bool = True,
		timeout: int | None = None,
	) -> StepResult:
		return self._run_step(label, cmd, required=required, env=self._simctl_env)

	def xCleanupService_run_simctl_step__mutmut_11(
		self,
		label: str,
		cmd: Sequence[str],
		*,
		required: bool = True,
		timeout: int | None = None,
	) -> StepResult:
		return self._run_step(label, cmd, required=required, timeout=timeout, )
	
	xCleanupService_run_simctl_step__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupService_run_simctl_step__mutmut_1': xCleanupService_run_simctl_step__mutmut_1, 
	    'xCleanupService_run_simctl_step__mutmut_2': xCleanupService_run_simctl_step__mutmut_2, 
	    'xCleanupService_run_simctl_step__mutmut_3': xCleanupService_run_simctl_step__mutmut_3, 
	    'xCleanupService_run_simctl_step__mutmut_4': xCleanupService_run_simctl_step__mutmut_4, 
	    'xCleanupService_run_simctl_step__mutmut_5': xCleanupService_run_simctl_step__mutmut_5, 
	    'xCleanupService_run_simctl_step__mutmut_6': xCleanupService_run_simctl_step__mutmut_6, 
	    'xCleanupService_run_simctl_step__mutmut_7': xCleanupService_run_simctl_step__mutmut_7, 
	    'xCleanupService_run_simctl_step__mutmut_8': xCleanupService_run_simctl_step__mutmut_8, 
	    'xCleanupService_run_simctl_step__mutmut_9': xCleanupService_run_simctl_step__mutmut_9, 
	    'xCleanupService_run_simctl_step__mutmut_10': xCleanupService_run_simctl_step__mutmut_10, 
	    'xCleanupService_run_simctl_step__mutmut_11': xCleanupService_run_simctl_step__mutmut_11
	}
	
	def _run_simctl_step(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupService_run_simctl_step__mutmut_orig"), object.__getattribute__(self, "xCleanupService_run_simctl_step__mutmut_mutants"), args, kwargs, self)
		return result 
	
	_run_simctl_step.__signature__ = _mutmut_signature(xCleanupService_run_simctl_step__mutmut_orig)
	xCleanupService_run_simctl_step__mutmut_orig.__name__ = 'xCleanupService_run_simctl_step'

	def xCleanupService_run_sudo_batch__mutmut_orig(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(" ".join(shlex.quote(part) for part in cmd))
		cmd_str = " ; ".join(parts)
		return self._run_step(label, ["/bin/sh", "-c", cmd_str], sudo=True, required=required)

	def xCleanupService_run_sudo_batch__mutmut_1(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = False,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(" ".join(shlex.quote(part) for part in cmd))
		cmd_str = " ; ".join(parts)
		return self._run_step(label, ["/bin/sh", "-c", cmd_str], sudo=True, required=required)

	def xCleanupService_run_sudo_batch__mutmut_2(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = None
		for cmd in commands:
			parts.append(" ".join(shlex.quote(part) for part in cmd))
		cmd_str = " ; ".join(parts)
		return self._run_step(label, ["/bin/sh", "-c", cmd_str], sudo=True, required=required)

	def xCleanupService_run_sudo_batch__mutmut_3(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(None)
		cmd_str = " ; ".join(parts)
		return self._run_step(label, ["/bin/sh", "-c", cmd_str], sudo=True, required=required)

	def xCleanupService_run_sudo_batch__mutmut_4(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(" ".join(None))
		cmd_str = " ; ".join(parts)
		return self._run_step(label, ["/bin/sh", "-c", cmd_str], sudo=True, required=required)

	def xCleanupService_run_sudo_batch__mutmut_5(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append("XX XX".join(shlex.quote(part) for part in cmd))
		cmd_str = " ; ".join(parts)
		return self._run_step(label, ["/bin/sh", "-c", cmd_str], sudo=True, required=required)

	def xCleanupService_run_sudo_batch__mutmut_6(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(" ".join(shlex.quote(None) for part in cmd))
		cmd_str = " ; ".join(parts)
		return self._run_step(label, ["/bin/sh", "-c", cmd_str], sudo=True, required=required)

	def xCleanupService_run_sudo_batch__mutmut_7(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(" ".join(shlex.quote(part) for part in cmd))
		cmd_str = None
		return self._run_step(label, ["/bin/sh", "-c", cmd_str], sudo=True, required=required)

	def xCleanupService_run_sudo_batch__mutmut_8(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(" ".join(shlex.quote(part) for part in cmd))
		cmd_str = " ; ".join(None)
		return self._run_step(label, ["/bin/sh", "-c", cmd_str], sudo=True, required=required)

	def xCleanupService_run_sudo_batch__mutmut_9(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(" ".join(shlex.quote(part) for part in cmd))
		cmd_str = "XX ; XX".join(parts)
		return self._run_step(label, ["/bin/sh", "-c", cmd_str], sudo=True, required=required)

	def xCleanupService_run_sudo_batch__mutmut_10(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(" ".join(shlex.quote(part) for part in cmd))
		cmd_str = " ; ".join(parts)
		return self._run_step(None, ["/bin/sh", "-c", cmd_str], sudo=True, required=required)

	def xCleanupService_run_sudo_batch__mutmut_11(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(" ".join(shlex.quote(part) for part in cmd))
		cmd_str = " ; ".join(parts)
		return self._run_step(label, None, sudo=True, required=required)

	def xCleanupService_run_sudo_batch__mutmut_12(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(" ".join(shlex.quote(part) for part in cmd))
		cmd_str = " ; ".join(parts)
		return self._run_step(label, ["/bin/sh", "-c", cmd_str], sudo=None, required=required)

	def xCleanupService_run_sudo_batch__mutmut_13(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(" ".join(shlex.quote(part) for part in cmd))
		cmd_str = " ; ".join(parts)
		return self._run_step(label, ["/bin/sh", "-c", cmd_str], sudo=True, required=None)

	def xCleanupService_run_sudo_batch__mutmut_14(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(" ".join(shlex.quote(part) for part in cmd))
		cmd_str = " ; ".join(parts)
		return self._run_step(["/bin/sh", "-c", cmd_str], sudo=True, required=required)

	def xCleanupService_run_sudo_batch__mutmut_15(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(" ".join(shlex.quote(part) for part in cmd))
		cmd_str = " ; ".join(parts)
		return self._run_step(label, sudo=True, required=required)

	def xCleanupService_run_sudo_batch__mutmut_16(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(" ".join(shlex.quote(part) for part in cmd))
		cmd_str = " ; ".join(parts)
		return self._run_step(label, ["/bin/sh", "-c", cmd_str], required=required)

	def xCleanupService_run_sudo_batch__mutmut_17(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(" ".join(shlex.quote(part) for part in cmd))
		cmd_str = " ; ".join(parts)
		return self._run_step(label, ["/bin/sh", "-c", cmd_str], sudo=True, )

	def xCleanupService_run_sudo_batch__mutmut_18(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(" ".join(shlex.quote(part) for part in cmd))
		cmd_str = " ; ".join(parts)
		return self._run_step(label, ["XX/bin/shXX", "-c", cmd_str], sudo=True, required=required)

	def xCleanupService_run_sudo_batch__mutmut_19(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(" ".join(shlex.quote(part) for part in cmd))
		cmd_str = " ; ".join(parts)
		return self._run_step(label, ["/BIN/SH", "-c", cmd_str], sudo=True, required=required)

	def xCleanupService_run_sudo_batch__mutmut_20(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(" ".join(shlex.quote(part) for part in cmd))
		cmd_str = " ; ".join(parts)
		return self._run_step(label, ["/bin/sh", "XX-cXX", cmd_str], sudo=True, required=required)

	def xCleanupService_run_sudo_batch__mutmut_21(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(" ".join(shlex.quote(part) for part in cmd))
		cmd_str = " ; ".join(parts)
		return self._run_step(label, ["/bin/sh", "-C", cmd_str], sudo=True, required=required)

	def xCleanupService_run_sudo_batch__mutmut_22(
		self,
		label: str,
		commands: Sequence[Sequence[str]],
		*,
		required: bool = True,
	) -> StepResult:
		parts = []
		for cmd in commands:
			parts.append(" ".join(shlex.quote(part) for part in cmd))
		cmd_str = " ; ".join(parts)
		return self._run_step(label, ["/bin/sh", "-c", cmd_str], sudo=False, required=required)
	
	xCleanupService_run_sudo_batch__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupService_run_sudo_batch__mutmut_1': xCleanupService_run_sudo_batch__mutmut_1, 
	    'xCleanupService_run_sudo_batch__mutmut_2': xCleanupService_run_sudo_batch__mutmut_2, 
	    'xCleanupService_run_sudo_batch__mutmut_3': xCleanupService_run_sudo_batch__mutmut_3, 
	    'xCleanupService_run_sudo_batch__mutmut_4': xCleanupService_run_sudo_batch__mutmut_4, 
	    'xCleanupService_run_sudo_batch__mutmut_5': xCleanupService_run_sudo_batch__mutmut_5, 
	    'xCleanupService_run_sudo_batch__mutmut_6': xCleanupService_run_sudo_batch__mutmut_6, 
	    'xCleanupService_run_sudo_batch__mutmut_7': xCleanupService_run_sudo_batch__mutmut_7, 
	    'xCleanupService_run_sudo_batch__mutmut_8': xCleanupService_run_sudo_batch__mutmut_8, 
	    'xCleanupService_run_sudo_batch__mutmut_9': xCleanupService_run_sudo_batch__mutmut_9, 
	    'xCleanupService_run_sudo_batch__mutmut_10': xCleanupService_run_sudo_batch__mutmut_10, 
	    'xCleanupService_run_sudo_batch__mutmut_11': xCleanupService_run_sudo_batch__mutmut_11, 
	    'xCleanupService_run_sudo_batch__mutmut_12': xCleanupService_run_sudo_batch__mutmut_12, 
	    'xCleanupService_run_sudo_batch__mutmut_13': xCleanupService_run_sudo_batch__mutmut_13, 
	    'xCleanupService_run_sudo_batch__mutmut_14': xCleanupService_run_sudo_batch__mutmut_14, 
	    'xCleanupService_run_sudo_batch__mutmut_15': xCleanupService_run_sudo_batch__mutmut_15, 
	    'xCleanupService_run_sudo_batch__mutmut_16': xCleanupService_run_sudo_batch__mutmut_16, 
	    'xCleanupService_run_sudo_batch__mutmut_17': xCleanupService_run_sudo_batch__mutmut_17, 
	    'xCleanupService_run_sudo_batch__mutmut_18': xCleanupService_run_sudo_batch__mutmut_18, 
	    'xCleanupService_run_sudo_batch__mutmut_19': xCleanupService_run_sudo_batch__mutmut_19, 
	    'xCleanupService_run_sudo_batch__mutmut_20': xCleanupService_run_sudo_batch__mutmut_20, 
	    'xCleanupService_run_sudo_batch__mutmut_21': xCleanupService_run_sudo_batch__mutmut_21, 
	    'xCleanupService_run_sudo_batch__mutmut_22': xCleanupService_run_sudo_batch__mutmut_22
	}
	
	def _run_sudo_batch(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupService_run_sudo_batch__mutmut_orig"), object.__getattribute__(self, "xCleanupService_run_sudo_batch__mutmut_mutants"), args, kwargs, self)
		return result 
	
	_run_sudo_batch.__signature__ = _mutmut_signature(xCleanupService_run_sudo_batch__mutmut_orig)
	xCleanupService_run_sudo_batch__mutmut_orig.__name__ = 'xCleanupService_run_sudo_batch'

	def xCleanupService_space_snapshot__mutmut_orig(self) -> Optional[int]:
		return svc_space.get_apfs_available_bytes(runner=self._runner)

	def xCleanupService_space_snapshot__mutmut_1(self) -> Optional[int]:
		return svc_space.get_apfs_available_bytes(runner=None)
	
	xCleanupService_space_snapshot__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupService_space_snapshot__mutmut_1': xCleanupService_space_snapshot__mutmut_1
	}
	
	def _space_snapshot(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupService_space_snapshot__mutmut_orig"), object.__getattribute__(self, "xCleanupService_space_snapshot__mutmut_mutants"), args, kwargs, self)
		return result 
	
	_space_snapshot.__signature__ = _mutmut_signature(xCleanupService_space_snapshot__mutmut_orig)
	xCleanupService_space_snapshot__mutmut_orig.__name__ = 'xCleanupService_space_snapshot'

	def xCleanupServicelist_runtimes__mutmut_orig(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["xcrun", "simctl", "runtime", "list", "-j"],
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_1(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = None
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_2(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			None,
			["xcrun", "simctl", "runtime", "list", "-j"],
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_3(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			None,
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_4(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["xcrun", "simctl", "runtime", "list", "-j"],
			required=None,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_5(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			["xcrun", "simctl", "runtime", "list", "-j"],
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_6(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_7(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["xcrun", "simctl", "runtime", "list", "-j"],
			)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_8(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"XXxcrun simctl runtime list -jXX",
			["xcrun", "simctl", "runtime", "list", "-j"],
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_9(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"XCRUN SIMCTL RUNTIME LIST -J",
			["xcrun", "simctl", "runtime", "list", "-j"],
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_10(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["XXxcrunXX", "simctl", "runtime", "list", "-j"],
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_11(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["XCRUN", "simctl", "runtime", "list", "-j"],
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_12(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["xcrun", "XXsimctlXX", "runtime", "list", "-j"],
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_13(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["xcrun", "SIMCTL", "runtime", "list", "-j"],
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_14(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["xcrun", "simctl", "XXruntimeXX", "list", "-j"],
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_15(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["xcrun", "simctl", "RUNTIME", "list", "-j"],
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_16(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["xcrun", "simctl", "runtime", "XXlistXX", "-j"],
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_17(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["xcrun", "simctl", "runtime", "LIST", "-j"],
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_18(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["xcrun", "simctl", "runtime", "list", "XX-jXX"],
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_19(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["xcrun", "simctl", "runtime", "list", "-J"],
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_20(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["xcrun", "simctl", "runtime", "list", "-j"],
			required=False,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_21(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["xcrun", "simctl", "runtime", "list", "-j"],
			required=True,
		)
		if step.result.returncode == 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_22(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["xcrun", "simctl", "runtime", "list", "-j"],
			required=True,
		)
		if step.result.returncode != 1:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_23(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["xcrun", "simctl", "runtime", "list", "-j"],
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() and "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_24(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["xcrun", "simctl", "runtime", "list", "-j"],
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "XXsimctl runtime list failedXX"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_25(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["xcrun", "simctl", "runtime", "list", "-j"],
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "SIMCTL RUNTIME LIST FAILED"
		runtimes, parse_error = parse_simctl_runtime_list(step.result.stdout)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_26(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["xcrun", "simctl", "runtime", "list", "-j"],
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = None
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None

	def xCleanupServicelist_runtimes__mutmut_27(self) -> Tuple[List[RuntimeInfo], StepResult, Optional[str]]:
		step = self._run_simctl_step(
			"xcrun simctl runtime list -j",
			["xcrun", "simctl", "runtime", "list", "-j"],
			required=True,
		)
		if step.result.returncode != 0:
			return [], step, step.result.stderr.strip() or "simctl runtime list failed"
		runtimes, parse_error = parse_simctl_runtime_list(None)
		if parse_error:
			return [], step, parse_error
		return runtimes, step, None
	
	xCleanupServicelist_runtimes__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupServicelist_runtimes__mutmut_1': xCleanupServicelist_runtimes__mutmut_1, 
	    'xCleanupServicelist_runtimes__mutmut_2': xCleanupServicelist_runtimes__mutmut_2, 
	    'xCleanupServicelist_runtimes__mutmut_3': xCleanupServicelist_runtimes__mutmut_3, 
	    'xCleanupServicelist_runtimes__mutmut_4': xCleanupServicelist_runtimes__mutmut_4, 
	    'xCleanupServicelist_runtimes__mutmut_5': xCleanupServicelist_runtimes__mutmut_5, 
	    'xCleanupServicelist_runtimes__mutmut_6': xCleanupServicelist_runtimes__mutmut_6, 
	    'xCleanupServicelist_runtimes__mutmut_7': xCleanupServicelist_runtimes__mutmut_7, 
	    'xCleanupServicelist_runtimes__mutmut_8': xCleanupServicelist_runtimes__mutmut_8, 
	    'xCleanupServicelist_runtimes__mutmut_9': xCleanupServicelist_runtimes__mutmut_9, 
	    'xCleanupServicelist_runtimes__mutmut_10': xCleanupServicelist_runtimes__mutmut_10, 
	    'xCleanupServicelist_runtimes__mutmut_11': xCleanupServicelist_runtimes__mutmut_11, 
	    'xCleanupServicelist_runtimes__mutmut_12': xCleanupServicelist_runtimes__mutmut_12, 
	    'xCleanupServicelist_runtimes__mutmut_13': xCleanupServicelist_runtimes__mutmut_13, 
	    'xCleanupServicelist_runtimes__mutmut_14': xCleanupServicelist_runtimes__mutmut_14, 
	    'xCleanupServicelist_runtimes__mutmut_15': xCleanupServicelist_runtimes__mutmut_15, 
	    'xCleanupServicelist_runtimes__mutmut_16': xCleanupServicelist_runtimes__mutmut_16, 
	    'xCleanupServicelist_runtimes__mutmut_17': xCleanupServicelist_runtimes__mutmut_17, 
	    'xCleanupServicelist_runtimes__mutmut_18': xCleanupServicelist_runtimes__mutmut_18, 
	    'xCleanupServicelist_runtimes__mutmut_19': xCleanupServicelist_runtimes__mutmut_19, 
	    'xCleanupServicelist_runtimes__mutmut_20': xCleanupServicelist_runtimes__mutmut_20, 
	    'xCleanupServicelist_runtimes__mutmut_21': xCleanupServicelist_runtimes__mutmut_21, 
	    'xCleanupServicelist_runtimes__mutmut_22': xCleanupServicelist_runtimes__mutmut_22, 
	    'xCleanupServicelist_runtimes__mutmut_23': xCleanupServicelist_runtimes__mutmut_23, 
	    'xCleanupServicelist_runtimes__mutmut_24': xCleanupServicelist_runtimes__mutmut_24, 
	    'xCleanupServicelist_runtimes__mutmut_25': xCleanupServicelist_runtimes__mutmut_25, 
	    'xCleanupServicelist_runtimes__mutmut_26': xCleanupServicelist_runtimes__mutmut_26, 
	    'xCleanupServicelist_runtimes__mutmut_27': xCleanupServicelist_runtimes__mutmut_27
	}
	
	def list_runtimes(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupServicelist_runtimes__mutmut_orig"), object.__getattribute__(self, "xCleanupServicelist_runtimes__mutmut_mutants"), args, kwargs, self)
		return result 
	
	list_runtimes.__signature__ = _mutmut_signature(xCleanupServicelist_runtimes__mutmut_orig)
	xCleanupServicelist_runtimes__mutmut_orig.__name__ = 'xCleanupServicelist_runtimes'

	def xCleanupServicedelete_runtimes__mutmut_orig(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "simctl", "runtime", "delete", runtime_id],
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_1(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = None
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "simctl", "runtime", "delete", runtime_id],
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_2(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = None
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_3(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				None,
				["xcrun", "simctl", "runtime", "delete", runtime_id],
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_4(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				None,
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_5(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "simctl", "runtime", "delete", runtime_id],
				required=None,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_6(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				["xcrun", "simctl", "runtime", "delete", runtime_id],
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_7(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_8(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "simctl", "runtime", "delete", runtime_id],
				)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_9(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["XXxcrunXX", "simctl", "runtime", "delete", runtime_id],
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_10(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["XCRUN", "simctl", "runtime", "delete", runtime_id],
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_11(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "XXsimctlXX", "runtime", "delete", runtime_id],
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_12(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "SIMCTL", "runtime", "delete", runtime_id],
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_13(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "simctl", "XXruntimeXX", "delete", runtime_id],
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_14(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "simctl", "RUNTIME", "delete", runtime_id],
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_15(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "simctl", "runtime", "XXdeleteXX", runtime_id],
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_16(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "simctl", "runtime", "DELETE", runtime_id],
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_17(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "simctl", "runtime", "delete", runtime_id],
				required=False,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_18(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "simctl", "runtime", "delete", runtime_id],
				required=True,
			)
			steps.append(None)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_19(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "simctl", "runtime", "delete", runtime_id],
				required=True,
			)
			steps.append(step)
		error = None
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_20(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "simctl", "runtime", "delete", runtime_id],
				required=True,
			)
			steps.append(step)
		error = _first_required_error(None)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_21(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "simctl", "runtime", "delete", runtime_id],
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=None, steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_22(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "simctl", "runtime", "delete", runtime_id],
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=None, error=error)

	def xCleanupServicedelete_runtimes__mutmut_23(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "simctl", "runtime", "delete", runtime_id],
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=None)

	def xCleanupServicedelete_runtimes__mutmut_24(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "simctl", "runtime", "delete", runtime_id],
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(steps=steps, error=error)

	def xCleanupServicedelete_runtimes__mutmut_25(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "simctl", "runtime", "delete", runtime_id],
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), error=error)

	def xCleanupServicedelete_runtimes__mutmut_26(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "simctl", "runtime", "delete", runtime_id],
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, )

	def xCleanupServicedelete_runtimes__mutmut_27(self, runtime_ids: Sequence[str]) -> ActionResult:
		steps: List[StepResult] = []
		for runtime_id in runtime_ids:
			step = self._run_simctl_step(
				f"xcrun simctl runtime delete {runtime_id}",
				["xcrun", "simctl", "runtime", "delete", runtime_id],
				required=True,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(None), steps=steps, error=error)
	
	xCleanupServicedelete_runtimes__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupServicedelete_runtimes__mutmut_1': xCleanupServicedelete_runtimes__mutmut_1, 
	    'xCleanupServicedelete_runtimes__mutmut_2': xCleanupServicedelete_runtimes__mutmut_2, 
	    'xCleanupServicedelete_runtimes__mutmut_3': xCleanupServicedelete_runtimes__mutmut_3, 
	    'xCleanupServicedelete_runtimes__mutmut_4': xCleanupServicedelete_runtimes__mutmut_4, 
	    'xCleanupServicedelete_runtimes__mutmut_5': xCleanupServicedelete_runtimes__mutmut_5, 
	    'xCleanupServicedelete_runtimes__mutmut_6': xCleanupServicedelete_runtimes__mutmut_6, 
	    'xCleanupServicedelete_runtimes__mutmut_7': xCleanupServicedelete_runtimes__mutmut_7, 
	    'xCleanupServicedelete_runtimes__mutmut_8': xCleanupServicedelete_runtimes__mutmut_8, 
	    'xCleanupServicedelete_runtimes__mutmut_9': xCleanupServicedelete_runtimes__mutmut_9, 
	    'xCleanupServicedelete_runtimes__mutmut_10': xCleanupServicedelete_runtimes__mutmut_10, 
	    'xCleanupServicedelete_runtimes__mutmut_11': xCleanupServicedelete_runtimes__mutmut_11, 
	    'xCleanupServicedelete_runtimes__mutmut_12': xCleanupServicedelete_runtimes__mutmut_12, 
	    'xCleanupServicedelete_runtimes__mutmut_13': xCleanupServicedelete_runtimes__mutmut_13, 
	    'xCleanupServicedelete_runtimes__mutmut_14': xCleanupServicedelete_runtimes__mutmut_14, 
	    'xCleanupServicedelete_runtimes__mutmut_15': xCleanupServicedelete_runtimes__mutmut_15, 
	    'xCleanupServicedelete_runtimes__mutmut_16': xCleanupServicedelete_runtimes__mutmut_16, 
	    'xCleanupServicedelete_runtimes__mutmut_17': xCleanupServicedelete_runtimes__mutmut_17, 
	    'xCleanupServicedelete_runtimes__mutmut_18': xCleanupServicedelete_runtimes__mutmut_18, 
	    'xCleanupServicedelete_runtimes__mutmut_19': xCleanupServicedelete_runtimes__mutmut_19, 
	    'xCleanupServicedelete_runtimes__mutmut_20': xCleanupServicedelete_runtimes__mutmut_20, 
	    'xCleanupServicedelete_runtimes__mutmut_21': xCleanupServicedelete_runtimes__mutmut_21, 
	    'xCleanupServicedelete_runtimes__mutmut_22': xCleanupServicedelete_runtimes__mutmut_22, 
	    'xCleanupServicedelete_runtimes__mutmut_23': xCleanupServicedelete_runtimes__mutmut_23, 
	    'xCleanupServicedelete_runtimes__mutmut_24': xCleanupServicedelete_runtimes__mutmut_24, 
	    'xCleanupServicedelete_runtimes__mutmut_25': xCleanupServicedelete_runtimes__mutmut_25, 
	    'xCleanupServicedelete_runtimes__mutmut_26': xCleanupServicedelete_runtimes__mutmut_26, 
	    'xCleanupServicedelete_runtimes__mutmut_27': xCleanupServicedelete_runtimes__mutmut_27
	}
	
	def delete_runtimes(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupServicedelete_runtimes__mutmut_orig"), object.__getattribute__(self, "xCleanupServicedelete_runtimes__mutmut_mutants"), args, kwargs, self)
		return result 
	
	delete_runtimes.__signature__ = _mutmut_signature(xCleanupServicedelete_runtimes__mutmut_orig)
	xCleanupServicedelete_runtimes__mutmut_orig.__name__ = 'xCleanupServicedelete_runtimes'

	def xCleanupServicedelete_all_runtimes__mutmut_orig(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_1(self) -> ActionResult:
		steps: List[StepResult] = None
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_2(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = None
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_3(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			None,
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_4(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			None,
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_5(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=None,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_6(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_7(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_8(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_9(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"XXxcrun simctl runtime delete allXX",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_10(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"XCRUN SIMCTL RUNTIME DELETE ALL",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_11(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["XXxcrunXX", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_12(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["XCRUN", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_13(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "XXsimctlXX", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_14(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "SIMCTL", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_15(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "XXruntimeXX", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_16(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "RUNTIME", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_17(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "XXdeleteXX", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_18(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "DELETE", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_19(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "XXallXX"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_20(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "ALL"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_21(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=True,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_22(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(None)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_23(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = None
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_24(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(None)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_25(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=None, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_26(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=None, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_27(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=None)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_28(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_29(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_30(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, )

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_31(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=True, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_32(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = None
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_33(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes(None)
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_34(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(None)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_35(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = None
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_36(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error and _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_37(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(None)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_38(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=None, steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_39(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=None, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_40(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=None)

	def xCleanupServicedelete_all_runtimes__mutmut_41(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(steps=steps, error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_42(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), error=error)

	def xCleanupServicedelete_all_runtimes__mutmut_43(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, )

	def xCleanupServicedelete_all_runtimes__mutmut_44(self) -> ActionResult:
		steps: List[StepResult] = []
		delete_all_step = self._run_simctl_step(
			"xcrun simctl runtime delete all",
			["xcrun", "simctl", "runtime", "delete", "all"],
			required=False,
		)
		steps.append(delete_all_step)

		runtimes, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		delete_result = self.delete_runtimes([runtime.identifier for runtime in runtimes])
		steps.extend(delete_result.steps)
		error = delete_result.error or _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(None), steps=steps, error=error)
	
	xCleanupServicedelete_all_runtimes__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupServicedelete_all_runtimes__mutmut_1': xCleanupServicedelete_all_runtimes__mutmut_1, 
	    'xCleanupServicedelete_all_runtimes__mutmut_2': xCleanupServicedelete_all_runtimes__mutmut_2, 
	    'xCleanupServicedelete_all_runtimes__mutmut_3': xCleanupServicedelete_all_runtimes__mutmut_3, 
	    'xCleanupServicedelete_all_runtimes__mutmut_4': xCleanupServicedelete_all_runtimes__mutmut_4, 
	    'xCleanupServicedelete_all_runtimes__mutmut_5': xCleanupServicedelete_all_runtimes__mutmut_5, 
	    'xCleanupServicedelete_all_runtimes__mutmut_6': xCleanupServicedelete_all_runtimes__mutmut_6, 
	    'xCleanupServicedelete_all_runtimes__mutmut_7': xCleanupServicedelete_all_runtimes__mutmut_7, 
	    'xCleanupServicedelete_all_runtimes__mutmut_8': xCleanupServicedelete_all_runtimes__mutmut_8, 
	    'xCleanupServicedelete_all_runtimes__mutmut_9': xCleanupServicedelete_all_runtimes__mutmut_9, 
	    'xCleanupServicedelete_all_runtimes__mutmut_10': xCleanupServicedelete_all_runtimes__mutmut_10, 
	    'xCleanupServicedelete_all_runtimes__mutmut_11': xCleanupServicedelete_all_runtimes__mutmut_11, 
	    'xCleanupServicedelete_all_runtimes__mutmut_12': xCleanupServicedelete_all_runtimes__mutmut_12, 
	    'xCleanupServicedelete_all_runtimes__mutmut_13': xCleanupServicedelete_all_runtimes__mutmut_13, 
	    'xCleanupServicedelete_all_runtimes__mutmut_14': xCleanupServicedelete_all_runtimes__mutmut_14, 
	    'xCleanupServicedelete_all_runtimes__mutmut_15': xCleanupServicedelete_all_runtimes__mutmut_15, 
	    'xCleanupServicedelete_all_runtimes__mutmut_16': xCleanupServicedelete_all_runtimes__mutmut_16, 
	    'xCleanupServicedelete_all_runtimes__mutmut_17': xCleanupServicedelete_all_runtimes__mutmut_17, 
	    'xCleanupServicedelete_all_runtimes__mutmut_18': xCleanupServicedelete_all_runtimes__mutmut_18, 
	    'xCleanupServicedelete_all_runtimes__mutmut_19': xCleanupServicedelete_all_runtimes__mutmut_19, 
	    'xCleanupServicedelete_all_runtimes__mutmut_20': xCleanupServicedelete_all_runtimes__mutmut_20, 
	    'xCleanupServicedelete_all_runtimes__mutmut_21': xCleanupServicedelete_all_runtimes__mutmut_21, 
	    'xCleanupServicedelete_all_runtimes__mutmut_22': xCleanupServicedelete_all_runtimes__mutmut_22, 
	    'xCleanupServicedelete_all_runtimes__mutmut_23': xCleanupServicedelete_all_runtimes__mutmut_23, 
	    'xCleanupServicedelete_all_runtimes__mutmut_24': xCleanupServicedelete_all_runtimes__mutmut_24, 
	    'xCleanupServicedelete_all_runtimes__mutmut_25': xCleanupServicedelete_all_runtimes__mutmut_25, 
	    'xCleanupServicedelete_all_runtimes__mutmut_26': xCleanupServicedelete_all_runtimes__mutmut_26, 
	    'xCleanupServicedelete_all_runtimes__mutmut_27': xCleanupServicedelete_all_runtimes__mutmut_27, 
	    'xCleanupServicedelete_all_runtimes__mutmut_28': xCleanupServicedelete_all_runtimes__mutmut_28, 
	    'xCleanupServicedelete_all_runtimes__mutmut_29': xCleanupServicedelete_all_runtimes__mutmut_29, 
	    'xCleanupServicedelete_all_runtimes__mutmut_30': xCleanupServicedelete_all_runtimes__mutmut_30, 
	    'xCleanupServicedelete_all_runtimes__mutmut_31': xCleanupServicedelete_all_runtimes__mutmut_31, 
	    'xCleanupServicedelete_all_runtimes__mutmut_32': xCleanupServicedelete_all_runtimes__mutmut_32, 
	    'xCleanupServicedelete_all_runtimes__mutmut_33': xCleanupServicedelete_all_runtimes__mutmut_33, 
	    'xCleanupServicedelete_all_runtimes__mutmut_34': xCleanupServicedelete_all_runtimes__mutmut_34, 
	    'xCleanupServicedelete_all_runtimes__mutmut_35': xCleanupServicedelete_all_runtimes__mutmut_35, 
	    'xCleanupServicedelete_all_runtimes__mutmut_36': xCleanupServicedelete_all_runtimes__mutmut_36, 
	    'xCleanupServicedelete_all_runtimes__mutmut_37': xCleanupServicedelete_all_runtimes__mutmut_37, 
	    'xCleanupServicedelete_all_runtimes__mutmut_38': xCleanupServicedelete_all_runtimes__mutmut_38, 
	    'xCleanupServicedelete_all_runtimes__mutmut_39': xCleanupServicedelete_all_runtimes__mutmut_39, 
	    'xCleanupServicedelete_all_runtimes__mutmut_40': xCleanupServicedelete_all_runtimes__mutmut_40, 
	    'xCleanupServicedelete_all_runtimes__mutmut_41': xCleanupServicedelete_all_runtimes__mutmut_41, 
	    'xCleanupServicedelete_all_runtimes__mutmut_42': xCleanupServicedelete_all_runtimes__mutmut_42, 
	    'xCleanupServicedelete_all_runtimes__mutmut_43': xCleanupServicedelete_all_runtimes__mutmut_43, 
	    'xCleanupServicedelete_all_runtimes__mutmut_44': xCleanupServicedelete_all_runtimes__mutmut_44
	}
	
	def delete_all_runtimes(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupServicedelete_all_runtimes__mutmut_orig"), object.__getattribute__(self, "xCleanupServicedelete_all_runtimes__mutmut_mutants"), args, kwargs, self)
		return result 
	
	delete_all_runtimes.__signature__ = _mutmut_signature(xCleanupServicedelete_all_runtimes__mutmut_orig)
	xCleanupServicedelete_all_runtimes__mutmut_orig.__name__ = 'xCleanupServicedelete_all_runtimes'

	def xCleanupServicedelete_unavailable_runtimes__mutmut_orig(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["xcrun", "simctl", "runtime", "delete", "unavailable"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_1(self) -> ActionResult:
		step = None
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_2(self) -> ActionResult:
		step = self._run_simctl_step(
			None,
			["xcrun", "simctl", "runtime", "delete", "unavailable"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_3(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			None,
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_4(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["xcrun", "simctl", "runtime", "delete", "unavailable"],
			required=None,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_5(self) -> ActionResult:
		step = self._run_simctl_step(
			["xcrun", "simctl", "runtime", "delete", "unavailable"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_6(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_7(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["xcrun", "simctl", "runtime", "delete", "unavailable"],
			)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_8(self) -> ActionResult:
		step = self._run_simctl_step(
			"XXxcrun simctl runtime delete unavailableXX",
			["xcrun", "simctl", "runtime", "delete", "unavailable"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_9(self) -> ActionResult:
		step = self._run_simctl_step(
			"XCRUN SIMCTL RUNTIME DELETE UNAVAILABLE",
			["xcrun", "simctl", "runtime", "delete", "unavailable"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_10(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["XXxcrunXX", "simctl", "runtime", "delete", "unavailable"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_11(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["XCRUN", "simctl", "runtime", "delete", "unavailable"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_12(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["xcrun", "XXsimctlXX", "runtime", "delete", "unavailable"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_13(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["xcrun", "SIMCTL", "runtime", "delete", "unavailable"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_14(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["xcrun", "simctl", "XXruntimeXX", "delete", "unavailable"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_15(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["xcrun", "simctl", "RUNTIME", "delete", "unavailable"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_16(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["xcrun", "simctl", "runtime", "XXdeleteXX", "unavailable"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_17(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["xcrun", "simctl", "runtime", "DELETE", "unavailable"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_18(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["xcrun", "simctl", "runtime", "delete", "XXunavailableXX"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_19(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["xcrun", "simctl", "runtime", "delete", "UNAVAILABLE"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_20(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["xcrun", "simctl", "runtime", "delete", "unavailable"],
			required=False,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_21(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["xcrun", "simctl", "runtime", "delete", "unavailable"],
			required=True,
		)
		error = None
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_22(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["xcrun", "simctl", "runtime", "delete", "unavailable"],
			required=True,
		)
		error = _first_required_error(None)
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_23(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["xcrun", "simctl", "runtime", "delete", "unavailable"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=None, steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_24(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["xcrun", "simctl", "runtime", "delete", "unavailable"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=None, error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_25(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["xcrun", "simctl", "runtime", "delete", "unavailable"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], error=None)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_26(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["xcrun", "simctl", "runtime", "delete", "unavailable"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(steps=[step], error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_27(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["xcrun", "simctl", "runtime", "delete", "unavailable"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, error=error)

	def xCleanupServicedelete_unavailable_runtimes__mutmut_28(self) -> ActionResult:
		step = self._run_simctl_step(
			"xcrun simctl runtime delete unavailable",
			["xcrun", "simctl", "runtime", "delete", "unavailable"],
			required=True,
		)
		error = _first_required_error([step])
		return ActionResult(commands_ok=step.ok, steps=[step], )
	
	xCleanupServicedelete_unavailable_runtimes__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupServicedelete_unavailable_runtimes__mutmut_1': xCleanupServicedelete_unavailable_runtimes__mutmut_1, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_2': xCleanupServicedelete_unavailable_runtimes__mutmut_2, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_3': xCleanupServicedelete_unavailable_runtimes__mutmut_3, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_4': xCleanupServicedelete_unavailable_runtimes__mutmut_4, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_5': xCleanupServicedelete_unavailable_runtimes__mutmut_5, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_6': xCleanupServicedelete_unavailable_runtimes__mutmut_6, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_7': xCleanupServicedelete_unavailable_runtimes__mutmut_7, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_8': xCleanupServicedelete_unavailable_runtimes__mutmut_8, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_9': xCleanupServicedelete_unavailable_runtimes__mutmut_9, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_10': xCleanupServicedelete_unavailable_runtimes__mutmut_10, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_11': xCleanupServicedelete_unavailable_runtimes__mutmut_11, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_12': xCleanupServicedelete_unavailable_runtimes__mutmut_12, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_13': xCleanupServicedelete_unavailable_runtimes__mutmut_13, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_14': xCleanupServicedelete_unavailable_runtimes__mutmut_14, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_15': xCleanupServicedelete_unavailable_runtimes__mutmut_15, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_16': xCleanupServicedelete_unavailable_runtimes__mutmut_16, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_17': xCleanupServicedelete_unavailable_runtimes__mutmut_17, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_18': xCleanupServicedelete_unavailable_runtimes__mutmut_18, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_19': xCleanupServicedelete_unavailable_runtimes__mutmut_19, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_20': xCleanupServicedelete_unavailable_runtimes__mutmut_20, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_21': xCleanupServicedelete_unavailable_runtimes__mutmut_21, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_22': xCleanupServicedelete_unavailable_runtimes__mutmut_22, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_23': xCleanupServicedelete_unavailable_runtimes__mutmut_23, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_24': xCleanupServicedelete_unavailable_runtimes__mutmut_24, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_25': xCleanupServicedelete_unavailable_runtimes__mutmut_25, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_26': xCleanupServicedelete_unavailable_runtimes__mutmut_26, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_27': xCleanupServicedelete_unavailable_runtimes__mutmut_27, 
	    'xCleanupServicedelete_unavailable_runtimes__mutmut_28': xCleanupServicedelete_unavailable_runtimes__mutmut_28
	}
	
	def delete_unavailable_runtimes(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupServicedelete_unavailable_runtimes__mutmut_orig"), object.__getattribute__(self, "xCleanupServicedelete_unavailable_runtimes__mutmut_mutants"), args, kwargs, self)
		return result 
	
	delete_unavailable_runtimes.__signature__ = _mutmut_signature(xCleanupServicedelete_unavailable_runtimes__mutmut_orig)
	xCleanupServicedelete_unavailable_runtimes__mutmut_orig.__name__ = 'xCleanupServicedelete_unavailable_runtimes'

	def xCleanupServicedelete_all_sim_devices__mutmut_orig(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_1(self) -> ActionResult:
		steps = None
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_2(self) -> ActionResult:
		steps = [
			self._run_simctl_step(None, ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_3(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", None, required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_4(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=None),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_5(self) -> ActionResult:
		steps = [
			self._run_simctl_step(["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_6(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_7(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], ),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_8(self) -> ActionResult:
		steps = [
			self._run_simctl_step("XXxcrun simctl shutdown allXX", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_9(self) -> ActionResult:
		steps = [
			self._run_simctl_step("XCRUN SIMCTL SHUTDOWN ALL", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_10(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["XXxcrunXX", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_11(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["XCRUN", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_12(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "XXsimctlXX", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_13(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "SIMCTL", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_14(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "XXshutdownXX", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_15(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "SHUTDOWN", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_16(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "XXallXX"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_17(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "ALL"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_18(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=False),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_19(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(None, ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_20(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", None, required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_21(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=None),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_22(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_23(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_24(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], ),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_25(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("XXxcrun simctl delete allXX", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_26(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("XCRUN SIMCTL DELETE ALL", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_27(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["XXxcrunXX", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_28(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["XCRUN", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_29(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "XXsimctlXX", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_30(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "SIMCTL", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_31(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "XXdeleteXX", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_32(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "DELETE", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_33(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "XXallXX"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_34(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "ALL"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_35(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=False),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_36(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = None
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_37(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(None)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_38(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=None, steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_39(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=None, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_40(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=None)

	def xCleanupServicedelete_all_sim_devices__mutmut_41(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(steps=steps, error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_42(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), error=error)

	def xCleanupServicedelete_all_sim_devices__mutmut_43(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, )

	def xCleanupServicedelete_all_sim_devices__mutmut_44(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step("xcrun simctl delete all", ["xcrun", "simctl", "delete", "all"], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(None), steps=steps, error=error)
	
	xCleanupServicedelete_all_sim_devices__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupServicedelete_all_sim_devices__mutmut_1': xCleanupServicedelete_all_sim_devices__mutmut_1, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_2': xCleanupServicedelete_all_sim_devices__mutmut_2, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_3': xCleanupServicedelete_all_sim_devices__mutmut_3, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_4': xCleanupServicedelete_all_sim_devices__mutmut_4, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_5': xCleanupServicedelete_all_sim_devices__mutmut_5, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_6': xCleanupServicedelete_all_sim_devices__mutmut_6, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_7': xCleanupServicedelete_all_sim_devices__mutmut_7, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_8': xCleanupServicedelete_all_sim_devices__mutmut_8, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_9': xCleanupServicedelete_all_sim_devices__mutmut_9, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_10': xCleanupServicedelete_all_sim_devices__mutmut_10, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_11': xCleanupServicedelete_all_sim_devices__mutmut_11, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_12': xCleanupServicedelete_all_sim_devices__mutmut_12, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_13': xCleanupServicedelete_all_sim_devices__mutmut_13, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_14': xCleanupServicedelete_all_sim_devices__mutmut_14, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_15': xCleanupServicedelete_all_sim_devices__mutmut_15, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_16': xCleanupServicedelete_all_sim_devices__mutmut_16, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_17': xCleanupServicedelete_all_sim_devices__mutmut_17, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_18': xCleanupServicedelete_all_sim_devices__mutmut_18, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_19': xCleanupServicedelete_all_sim_devices__mutmut_19, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_20': xCleanupServicedelete_all_sim_devices__mutmut_20, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_21': xCleanupServicedelete_all_sim_devices__mutmut_21, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_22': xCleanupServicedelete_all_sim_devices__mutmut_22, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_23': xCleanupServicedelete_all_sim_devices__mutmut_23, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_24': xCleanupServicedelete_all_sim_devices__mutmut_24, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_25': xCleanupServicedelete_all_sim_devices__mutmut_25, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_26': xCleanupServicedelete_all_sim_devices__mutmut_26, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_27': xCleanupServicedelete_all_sim_devices__mutmut_27, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_28': xCleanupServicedelete_all_sim_devices__mutmut_28, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_29': xCleanupServicedelete_all_sim_devices__mutmut_29, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_30': xCleanupServicedelete_all_sim_devices__mutmut_30, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_31': xCleanupServicedelete_all_sim_devices__mutmut_31, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_32': xCleanupServicedelete_all_sim_devices__mutmut_32, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_33': xCleanupServicedelete_all_sim_devices__mutmut_33, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_34': xCleanupServicedelete_all_sim_devices__mutmut_34, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_35': xCleanupServicedelete_all_sim_devices__mutmut_35, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_36': xCleanupServicedelete_all_sim_devices__mutmut_36, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_37': xCleanupServicedelete_all_sim_devices__mutmut_37, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_38': xCleanupServicedelete_all_sim_devices__mutmut_38, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_39': xCleanupServicedelete_all_sim_devices__mutmut_39, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_40': xCleanupServicedelete_all_sim_devices__mutmut_40, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_41': xCleanupServicedelete_all_sim_devices__mutmut_41, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_42': xCleanupServicedelete_all_sim_devices__mutmut_42, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_43': xCleanupServicedelete_all_sim_devices__mutmut_43, 
	    'xCleanupServicedelete_all_sim_devices__mutmut_44': xCleanupServicedelete_all_sim_devices__mutmut_44
	}
	
	def delete_all_sim_devices(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupServicedelete_all_sim_devices__mutmut_orig"), object.__getattribute__(self, "xCleanupServicedelete_all_sim_devices__mutmut_mutants"), args, kwargs, self)
		return result 
	
	delete_all_sim_devices.__signature__ = _mutmut_signature(xCleanupServicedelete_all_sim_devices__mutmut_orig)
	xCleanupServicedelete_all_sim_devices__mutmut_orig.__name__ = 'xCleanupServicedelete_all_sim_devices'

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_orig(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_1(self) -> ActionResult:
		steps = None
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_2(self) -> ActionResult:
		steps = [
			self._run_simctl_step(None, ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_3(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", None, required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_4(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=None),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_5(self) -> ActionResult:
		steps = [
			self._run_simctl_step(["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_6(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_7(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], ),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_8(self) -> ActionResult:
		steps = [
			self._run_simctl_step("XXxcrun simctl shutdown allXX", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_9(self) -> ActionResult:
		steps = [
			self._run_simctl_step("XCRUN SIMCTL SHUTDOWN ALL", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_10(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["XXxcrunXX", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_11(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["XCRUN", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_12(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "XXsimctlXX", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_13(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "SIMCTL", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_14(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "XXshutdownXX", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_15(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "SHUTDOWN", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_16(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "XXallXX"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_17(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "ALL"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_18(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=False),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_19(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				None,
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_20(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				None,
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_21(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=None,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_22(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_23(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_24(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_25(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"XXxcrun simctl delete unavailableXX",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_26(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"XCRUN SIMCTL DELETE UNAVAILABLE",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_27(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["XXxcrunXX", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_28(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["XCRUN", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_29(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "XXsimctlXX", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_30(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "SIMCTL", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_31(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "XXdeleteXX", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_32(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "DELETE", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_33(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "XXunavailableXX"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_34(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "UNAVAILABLE"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_35(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=False,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_36(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = None
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_37(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(None)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_38(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=None, steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_39(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=None, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_40(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=None)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_41(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(steps=steps, error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_42(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), error=error)

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_43(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, )

	def xCleanupServicedelete_unavailable_sim_devices__mutmut_44(self) -> ActionResult:
		steps = [
			self._run_simctl_step("xcrun simctl shutdown all", ["xcrun", "simctl", "shutdown", "all"], required=True),
			self._run_simctl_step(
				"xcrun simctl delete unavailable",
				["xcrun", "simctl", "delete", "unavailable"],
				required=True,
			),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(None), steps=steps, error=error)
	
	xCleanupServicedelete_unavailable_sim_devices__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupServicedelete_unavailable_sim_devices__mutmut_1': xCleanupServicedelete_unavailable_sim_devices__mutmut_1, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_2': xCleanupServicedelete_unavailable_sim_devices__mutmut_2, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_3': xCleanupServicedelete_unavailable_sim_devices__mutmut_3, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_4': xCleanupServicedelete_unavailable_sim_devices__mutmut_4, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_5': xCleanupServicedelete_unavailable_sim_devices__mutmut_5, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_6': xCleanupServicedelete_unavailable_sim_devices__mutmut_6, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_7': xCleanupServicedelete_unavailable_sim_devices__mutmut_7, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_8': xCleanupServicedelete_unavailable_sim_devices__mutmut_8, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_9': xCleanupServicedelete_unavailable_sim_devices__mutmut_9, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_10': xCleanupServicedelete_unavailable_sim_devices__mutmut_10, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_11': xCleanupServicedelete_unavailable_sim_devices__mutmut_11, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_12': xCleanupServicedelete_unavailable_sim_devices__mutmut_12, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_13': xCleanupServicedelete_unavailable_sim_devices__mutmut_13, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_14': xCleanupServicedelete_unavailable_sim_devices__mutmut_14, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_15': xCleanupServicedelete_unavailable_sim_devices__mutmut_15, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_16': xCleanupServicedelete_unavailable_sim_devices__mutmut_16, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_17': xCleanupServicedelete_unavailable_sim_devices__mutmut_17, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_18': xCleanupServicedelete_unavailable_sim_devices__mutmut_18, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_19': xCleanupServicedelete_unavailable_sim_devices__mutmut_19, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_20': xCleanupServicedelete_unavailable_sim_devices__mutmut_20, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_21': xCleanupServicedelete_unavailable_sim_devices__mutmut_21, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_22': xCleanupServicedelete_unavailable_sim_devices__mutmut_22, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_23': xCleanupServicedelete_unavailable_sim_devices__mutmut_23, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_24': xCleanupServicedelete_unavailable_sim_devices__mutmut_24, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_25': xCleanupServicedelete_unavailable_sim_devices__mutmut_25, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_26': xCleanupServicedelete_unavailable_sim_devices__mutmut_26, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_27': xCleanupServicedelete_unavailable_sim_devices__mutmut_27, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_28': xCleanupServicedelete_unavailable_sim_devices__mutmut_28, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_29': xCleanupServicedelete_unavailable_sim_devices__mutmut_29, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_30': xCleanupServicedelete_unavailable_sim_devices__mutmut_30, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_31': xCleanupServicedelete_unavailable_sim_devices__mutmut_31, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_32': xCleanupServicedelete_unavailable_sim_devices__mutmut_32, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_33': xCleanupServicedelete_unavailable_sim_devices__mutmut_33, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_34': xCleanupServicedelete_unavailable_sim_devices__mutmut_34, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_35': xCleanupServicedelete_unavailable_sim_devices__mutmut_35, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_36': xCleanupServicedelete_unavailable_sim_devices__mutmut_36, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_37': xCleanupServicedelete_unavailable_sim_devices__mutmut_37, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_38': xCleanupServicedelete_unavailable_sim_devices__mutmut_38, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_39': xCleanupServicedelete_unavailable_sim_devices__mutmut_39, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_40': xCleanupServicedelete_unavailable_sim_devices__mutmut_40, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_41': xCleanupServicedelete_unavailable_sim_devices__mutmut_41, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_42': xCleanupServicedelete_unavailable_sim_devices__mutmut_42, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_43': xCleanupServicedelete_unavailable_sim_devices__mutmut_43, 
	    'xCleanupServicedelete_unavailable_sim_devices__mutmut_44': xCleanupServicedelete_unavailable_sim_devices__mutmut_44
	}
	
	def delete_unavailable_sim_devices(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupServicedelete_unavailable_sim_devices__mutmut_orig"), object.__getattribute__(self, "xCleanupServicedelete_unavailable_sim_devices__mutmut_mutants"), args, kwargs, self)
		return result 
	
	delete_unavailable_sim_devices.__signature__ = _mutmut_signature(xCleanupServicedelete_unavailable_sim_devices__mutmut_orig)
	xCleanupServicedelete_unavailable_sim_devices__mutmut_orig.__name__ = 'xCleanupServicedelete_unavailable_sim_devices'

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_orig(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_1(self) -> ActionResult:
		devices_path = None
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_2(self) -> ActionResult:
		devices_path = os.path.expanduser(None)
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_3(self) -> ActionResult:
		devices_path = os.path.expanduser("XX~/Library/Developer/CoreSimulator/DevicesXX")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_4(self) -> ActionResult:
		devices_path = os.path.expanduser("~/library/developer/coresimulator/devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_5(self) -> ActionResult:
		devices_path = os.path.expanduser("~/LIBRARY/DEVELOPER/CORESIMULATOR/DEVICES")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_6(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = None
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_7(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser(None)
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_8(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("XX~/Library/Developer/CoreSimulator/ProfilesXX")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_9(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/library/developer/coresimulator/profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_10(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/LIBRARY/DEVELOPER/CORESIMULATOR/PROFILES")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_11(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = None
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_12(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(None, ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_13(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", None, required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_14(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=None),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_15(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_16(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_17(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], ),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_18(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["XXrmXX", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_19(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["RM", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_20(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "XX-rfXX", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_21(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-RF", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_22(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=False),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_23(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(None, ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_24(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", None, required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_25(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=None),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_26(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_27(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_28(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], ),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_29(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["XXrmXX", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_30(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["RM", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_31(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "XX-rfXX", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_32(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-RF", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_33(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=False),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_34(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = None
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_35(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(None)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_36(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=None, steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_37(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=None, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_38(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=None)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_39(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(steps=steps, error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_40(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), error=error)

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_41(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, )

	def xCleanupServiceremove_device_directories_and_profiles__mutmut_42(self) -> ActionResult:
		devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
		profiles_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Profiles")
		steps = [
			self._run_step(f"rm -rf {devices_path}", ["rm", "-rf", devices_path], required=True),
			self._run_step(f"rm -rf {profiles_path}", ["rm", "-rf", profiles_path], required=True),
		]
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(None), steps=steps, error=error)
	
	xCleanupServiceremove_device_directories_and_profiles__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupServiceremove_device_directories_and_profiles__mutmut_1': xCleanupServiceremove_device_directories_and_profiles__mutmut_1, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_2': xCleanupServiceremove_device_directories_and_profiles__mutmut_2, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_3': xCleanupServiceremove_device_directories_and_profiles__mutmut_3, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_4': xCleanupServiceremove_device_directories_and_profiles__mutmut_4, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_5': xCleanupServiceremove_device_directories_and_profiles__mutmut_5, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_6': xCleanupServiceremove_device_directories_and_profiles__mutmut_6, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_7': xCleanupServiceremove_device_directories_and_profiles__mutmut_7, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_8': xCleanupServiceremove_device_directories_and_profiles__mutmut_8, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_9': xCleanupServiceremove_device_directories_and_profiles__mutmut_9, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_10': xCleanupServiceremove_device_directories_and_profiles__mutmut_10, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_11': xCleanupServiceremove_device_directories_and_profiles__mutmut_11, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_12': xCleanupServiceremove_device_directories_and_profiles__mutmut_12, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_13': xCleanupServiceremove_device_directories_and_profiles__mutmut_13, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_14': xCleanupServiceremove_device_directories_and_profiles__mutmut_14, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_15': xCleanupServiceremove_device_directories_and_profiles__mutmut_15, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_16': xCleanupServiceremove_device_directories_and_profiles__mutmut_16, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_17': xCleanupServiceremove_device_directories_and_profiles__mutmut_17, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_18': xCleanupServiceremove_device_directories_and_profiles__mutmut_18, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_19': xCleanupServiceremove_device_directories_and_profiles__mutmut_19, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_20': xCleanupServiceremove_device_directories_and_profiles__mutmut_20, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_21': xCleanupServiceremove_device_directories_and_profiles__mutmut_21, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_22': xCleanupServiceremove_device_directories_and_profiles__mutmut_22, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_23': xCleanupServiceremove_device_directories_and_profiles__mutmut_23, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_24': xCleanupServiceremove_device_directories_and_profiles__mutmut_24, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_25': xCleanupServiceremove_device_directories_and_profiles__mutmut_25, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_26': xCleanupServiceremove_device_directories_and_profiles__mutmut_26, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_27': xCleanupServiceremove_device_directories_and_profiles__mutmut_27, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_28': xCleanupServiceremove_device_directories_and_profiles__mutmut_28, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_29': xCleanupServiceremove_device_directories_and_profiles__mutmut_29, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_30': xCleanupServiceremove_device_directories_and_profiles__mutmut_30, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_31': xCleanupServiceremove_device_directories_and_profiles__mutmut_31, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_32': xCleanupServiceremove_device_directories_and_profiles__mutmut_32, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_33': xCleanupServiceremove_device_directories_and_profiles__mutmut_33, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_34': xCleanupServiceremove_device_directories_and_profiles__mutmut_34, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_35': xCleanupServiceremove_device_directories_and_profiles__mutmut_35, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_36': xCleanupServiceremove_device_directories_and_profiles__mutmut_36, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_37': xCleanupServiceremove_device_directories_and_profiles__mutmut_37, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_38': xCleanupServiceremove_device_directories_and_profiles__mutmut_38, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_39': xCleanupServiceremove_device_directories_and_profiles__mutmut_39, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_40': xCleanupServiceremove_device_directories_and_profiles__mutmut_40, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_41': xCleanupServiceremove_device_directories_and_profiles__mutmut_41, 
	    'xCleanupServiceremove_device_directories_and_profiles__mutmut_42': xCleanupServiceremove_device_directories_and_profiles__mutmut_42
	}
	
	def remove_device_directories_and_profiles(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupServiceremove_device_directories_and_profiles__mutmut_orig"), object.__getattribute__(self, "xCleanupServiceremove_device_directories_and_profiles__mutmut_mutants"), args, kwargs, self)
		return result 
	
	remove_device_directories_and_profiles.__signature__ = _mutmut_signature(xCleanupServiceremove_device_directories_and_profiles__mutmut_orig)
	xCleanupServiceremove_device_directories_and_profiles__mutmut_orig.__name__ = 'xCleanupServiceremove_device_directories_and_profiles'

	def xCleanupServiceclear_paths__mutmut_orig(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-rf", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_1(self, paths: Sequence[str], *, sudo: bool = True) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-rf", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_2(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = None
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-rf", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_3(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = None
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-rf", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_4(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(None)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-rf", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_5(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = None
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_6(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				None,
				["rm", "-rf", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_7(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				None,
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_8(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-rf", expanded],
				required=None,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_9(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-rf", expanded],
				required=True,
				sudo=None,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_10(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				["rm", "-rf", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_11(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_12(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-rf", expanded],
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_13(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-rf", expanded],
				required=True,
				)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_14(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["XXrmXX", "-rf", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_15(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["RM", "-rf", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_16(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "XX-rfXX", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_17(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-RF", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_18(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-rf", expanded],
				required=False,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_19(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-rf", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(None)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_20(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-rf", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = None
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_21(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-rf", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(None)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_22(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-rf", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=None, steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_23(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-rf", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=None, error=error)

	def xCleanupServiceclear_paths__mutmut_24(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-rf", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=None)

	def xCleanupServiceclear_paths__mutmut_25(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-rf", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(steps=steps, error=error)

	def xCleanupServiceclear_paths__mutmut_26(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-rf", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), error=error)

	def xCleanupServiceclear_paths__mutmut_27(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-rf", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, )

	def xCleanupServiceclear_paths__mutmut_28(self, paths: Sequence[str], *, sudo: bool = False) -> ActionResult:
		steps: List[StepResult] = []
		for path in paths:
			expanded = os.path.expanduser(path)
			step = self._run_step(
				f"rm -rf {expanded}",
				["rm", "-rf", expanded],
				required=True,
				sudo=sudo,
			)
			steps.append(step)
		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(None), steps=steps, error=error)
	
	xCleanupServiceclear_paths__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupServiceclear_paths__mutmut_1': xCleanupServiceclear_paths__mutmut_1, 
	    'xCleanupServiceclear_paths__mutmut_2': xCleanupServiceclear_paths__mutmut_2, 
	    'xCleanupServiceclear_paths__mutmut_3': xCleanupServiceclear_paths__mutmut_3, 
	    'xCleanupServiceclear_paths__mutmut_4': xCleanupServiceclear_paths__mutmut_4, 
	    'xCleanupServiceclear_paths__mutmut_5': xCleanupServiceclear_paths__mutmut_5, 
	    'xCleanupServiceclear_paths__mutmut_6': xCleanupServiceclear_paths__mutmut_6, 
	    'xCleanupServiceclear_paths__mutmut_7': xCleanupServiceclear_paths__mutmut_7, 
	    'xCleanupServiceclear_paths__mutmut_8': xCleanupServiceclear_paths__mutmut_8, 
	    'xCleanupServiceclear_paths__mutmut_9': xCleanupServiceclear_paths__mutmut_9, 
	    'xCleanupServiceclear_paths__mutmut_10': xCleanupServiceclear_paths__mutmut_10, 
	    'xCleanupServiceclear_paths__mutmut_11': xCleanupServiceclear_paths__mutmut_11, 
	    'xCleanupServiceclear_paths__mutmut_12': xCleanupServiceclear_paths__mutmut_12, 
	    'xCleanupServiceclear_paths__mutmut_13': xCleanupServiceclear_paths__mutmut_13, 
	    'xCleanupServiceclear_paths__mutmut_14': xCleanupServiceclear_paths__mutmut_14, 
	    'xCleanupServiceclear_paths__mutmut_15': xCleanupServiceclear_paths__mutmut_15, 
	    'xCleanupServiceclear_paths__mutmut_16': xCleanupServiceclear_paths__mutmut_16, 
	    'xCleanupServiceclear_paths__mutmut_17': xCleanupServiceclear_paths__mutmut_17, 
	    'xCleanupServiceclear_paths__mutmut_18': xCleanupServiceclear_paths__mutmut_18, 
	    'xCleanupServiceclear_paths__mutmut_19': xCleanupServiceclear_paths__mutmut_19, 
	    'xCleanupServiceclear_paths__mutmut_20': xCleanupServiceclear_paths__mutmut_20, 
	    'xCleanupServiceclear_paths__mutmut_21': xCleanupServiceclear_paths__mutmut_21, 
	    'xCleanupServiceclear_paths__mutmut_22': xCleanupServiceclear_paths__mutmut_22, 
	    'xCleanupServiceclear_paths__mutmut_23': xCleanupServiceclear_paths__mutmut_23, 
	    'xCleanupServiceclear_paths__mutmut_24': xCleanupServiceclear_paths__mutmut_24, 
	    'xCleanupServiceclear_paths__mutmut_25': xCleanupServiceclear_paths__mutmut_25, 
	    'xCleanupServiceclear_paths__mutmut_26': xCleanupServiceclear_paths__mutmut_26, 
	    'xCleanupServiceclear_paths__mutmut_27': xCleanupServiceclear_paths__mutmut_27, 
	    'xCleanupServiceclear_paths__mutmut_28': xCleanupServiceclear_paths__mutmut_28
	}
	
	def clear_paths(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupServiceclear_paths__mutmut_orig"), object.__getattribute__(self, "xCleanupServiceclear_paths__mutmut_mutants"), args, kwargs, self)
		return result 
	
	clear_paths.__signature__ = _mutmut_signature(xCleanupServiceclear_paths__mutmut_orig)
	xCleanupServiceclear_paths__mutmut_orig.__name__ = 'xCleanupServiceclear_paths'

	def xCleanupServiceclear_all_simulator_caches__mutmut_orig(self) -> ActionResult:
		paths = [
			"~/Library/Developer/CoreSimulator/Caches",
			"~/Library/Developer/CoreSimulator/Temp",
			"~/Library/Caches/com.apple.CoreSimulator",
			"~/Library/Developer/Xcode/DerivedData",
		]
		return self.clear_paths(paths, sudo=False)

	def xCleanupServiceclear_all_simulator_caches__mutmut_1(self) -> ActionResult:
		paths = None
		return self.clear_paths(paths, sudo=False)

	def xCleanupServiceclear_all_simulator_caches__mutmut_2(self) -> ActionResult:
		paths = [
			"XX~/Library/Developer/CoreSimulator/CachesXX",
			"~/Library/Developer/CoreSimulator/Temp",
			"~/Library/Caches/com.apple.CoreSimulator",
			"~/Library/Developer/Xcode/DerivedData",
		]
		return self.clear_paths(paths, sudo=False)

	def xCleanupServiceclear_all_simulator_caches__mutmut_3(self) -> ActionResult:
		paths = [
			"~/library/developer/coresimulator/caches",
			"~/Library/Developer/CoreSimulator/Temp",
			"~/Library/Caches/com.apple.CoreSimulator",
			"~/Library/Developer/Xcode/DerivedData",
		]
		return self.clear_paths(paths, sudo=False)

	def xCleanupServiceclear_all_simulator_caches__mutmut_4(self) -> ActionResult:
		paths = [
			"~/LIBRARY/DEVELOPER/CORESIMULATOR/CACHES",
			"~/Library/Developer/CoreSimulator/Temp",
			"~/Library/Caches/com.apple.CoreSimulator",
			"~/Library/Developer/Xcode/DerivedData",
		]
		return self.clear_paths(paths, sudo=False)

	def xCleanupServiceclear_all_simulator_caches__mutmut_5(self) -> ActionResult:
		paths = [
			"~/Library/Developer/CoreSimulator/Caches",
			"XX~/Library/Developer/CoreSimulator/TempXX",
			"~/Library/Caches/com.apple.CoreSimulator",
			"~/Library/Developer/Xcode/DerivedData",
		]
		return self.clear_paths(paths, sudo=False)

	def xCleanupServiceclear_all_simulator_caches__mutmut_6(self) -> ActionResult:
		paths = [
			"~/Library/Developer/CoreSimulator/Caches",
			"~/library/developer/coresimulator/temp",
			"~/Library/Caches/com.apple.CoreSimulator",
			"~/Library/Developer/Xcode/DerivedData",
		]
		return self.clear_paths(paths, sudo=False)

	def xCleanupServiceclear_all_simulator_caches__mutmut_7(self) -> ActionResult:
		paths = [
			"~/Library/Developer/CoreSimulator/Caches",
			"~/LIBRARY/DEVELOPER/CORESIMULATOR/TEMP",
			"~/Library/Caches/com.apple.CoreSimulator",
			"~/Library/Developer/Xcode/DerivedData",
		]
		return self.clear_paths(paths, sudo=False)

	def xCleanupServiceclear_all_simulator_caches__mutmut_8(self) -> ActionResult:
		paths = [
			"~/Library/Developer/CoreSimulator/Caches",
			"~/Library/Developer/CoreSimulator/Temp",
			"XX~/Library/Caches/com.apple.CoreSimulatorXX",
			"~/Library/Developer/Xcode/DerivedData",
		]
		return self.clear_paths(paths, sudo=False)

	def xCleanupServiceclear_all_simulator_caches__mutmut_9(self) -> ActionResult:
		paths = [
			"~/Library/Developer/CoreSimulator/Caches",
			"~/Library/Developer/CoreSimulator/Temp",
			"~/library/caches/com.apple.coresimulator",
			"~/Library/Developer/Xcode/DerivedData",
		]
		return self.clear_paths(paths, sudo=False)

	def xCleanupServiceclear_all_simulator_caches__mutmut_10(self) -> ActionResult:
		paths = [
			"~/Library/Developer/CoreSimulator/Caches",
			"~/Library/Developer/CoreSimulator/Temp",
			"~/LIBRARY/CACHES/COM.APPLE.CORESIMULATOR",
			"~/Library/Developer/Xcode/DerivedData",
		]
		return self.clear_paths(paths, sudo=False)

	def xCleanupServiceclear_all_simulator_caches__mutmut_11(self) -> ActionResult:
		paths = [
			"~/Library/Developer/CoreSimulator/Caches",
			"~/Library/Developer/CoreSimulator/Temp",
			"~/Library/Caches/com.apple.CoreSimulator",
			"XX~/Library/Developer/Xcode/DerivedDataXX",
		]
		return self.clear_paths(paths, sudo=False)

	def xCleanupServiceclear_all_simulator_caches__mutmut_12(self) -> ActionResult:
		paths = [
			"~/Library/Developer/CoreSimulator/Caches",
			"~/Library/Developer/CoreSimulator/Temp",
			"~/Library/Caches/com.apple.CoreSimulator",
			"~/library/developer/xcode/deriveddata",
		]
		return self.clear_paths(paths, sudo=False)

	def xCleanupServiceclear_all_simulator_caches__mutmut_13(self) -> ActionResult:
		paths = [
			"~/Library/Developer/CoreSimulator/Caches",
			"~/Library/Developer/CoreSimulator/Temp",
			"~/Library/Caches/com.apple.CoreSimulator",
			"~/LIBRARY/DEVELOPER/XCODE/DERIVEDDATA",
		]
		return self.clear_paths(paths, sudo=False)

	def xCleanupServiceclear_all_simulator_caches__mutmut_14(self) -> ActionResult:
		paths = [
			"~/Library/Developer/CoreSimulator/Caches",
			"~/Library/Developer/CoreSimulator/Temp",
			"~/Library/Caches/com.apple.CoreSimulator",
			"~/Library/Developer/Xcode/DerivedData",
		]
		return self.clear_paths(None, sudo=False)

	def xCleanupServiceclear_all_simulator_caches__mutmut_15(self) -> ActionResult:
		paths = [
			"~/Library/Developer/CoreSimulator/Caches",
			"~/Library/Developer/CoreSimulator/Temp",
			"~/Library/Caches/com.apple.CoreSimulator",
			"~/Library/Developer/Xcode/DerivedData",
		]
		return self.clear_paths(paths, sudo=None)

	def xCleanupServiceclear_all_simulator_caches__mutmut_16(self) -> ActionResult:
		paths = [
			"~/Library/Developer/CoreSimulator/Caches",
			"~/Library/Developer/CoreSimulator/Temp",
			"~/Library/Caches/com.apple.CoreSimulator",
			"~/Library/Developer/Xcode/DerivedData",
		]
		return self.clear_paths(sudo=False)

	def xCleanupServiceclear_all_simulator_caches__mutmut_17(self) -> ActionResult:
		paths = [
			"~/Library/Developer/CoreSimulator/Caches",
			"~/Library/Developer/CoreSimulator/Temp",
			"~/Library/Caches/com.apple.CoreSimulator",
			"~/Library/Developer/Xcode/DerivedData",
		]
		return self.clear_paths(paths, )

	def xCleanupServiceclear_all_simulator_caches__mutmut_18(self) -> ActionResult:
		paths = [
			"~/Library/Developer/CoreSimulator/Caches",
			"~/Library/Developer/CoreSimulator/Temp",
			"~/Library/Caches/com.apple.CoreSimulator",
			"~/Library/Developer/Xcode/DerivedData",
		]
		return self.clear_paths(paths, sudo=True)
	
	xCleanupServiceclear_all_simulator_caches__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupServiceclear_all_simulator_caches__mutmut_1': xCleanupServiceclear_all_simulator_caches__mutmut_1, 
	    'xCleanupServiceclear_all_simulator_caches__mutmut_2': xCleanupServiceclear_all_simulator_caches__mutmut_2, 
	    'xCleanupServiceclear_all_simulator_caches__mutmut_3': xCleanupServiceclear_all_simulator_caches__mutmut_3, 
	    'xCleanupServiceclear_all_simulator_caches__mutmut_4': xCleanupServiceclear_all_simulator_caches__mutmut_4, 
	    'xCleanupServiceclear_all_simulator_caches__mutmut_5': xCleanupServiceclear_all_simulator_caches__mutmut_5, 
	    'xCleanupServiceclear_all_simulator_caches__mutmut_6': xCleanupServiceclear_all_simulator_caches__mutmut_6, 
	    'xCleanupServiceclear_all_simulator_caches__mutmut_7': xCleanupServiceclear_all_simulator_caches__mutmut_7, 
	    'xCleanupServiceclear_all_simulator_caches__mutmut_8': xCleanupServiceclear_all_simulator_caches__mutmut_8, 
	    'xCleanupServiceclear_all_simulator_caches__mutmut_9': xCleanupServiceclear_all_simulator_caches__mutmut_9, 
	    'xCleanupServiceclear_all_simulator_caches__mutmut_10': xCleanupServiceclear_all_simulator_caches__mutmut_10, 
	    'xCleanupServiceclear_all_simulator_caches__mutmut_11': xCleanupServiceclear_all_simulator_caches__mutmut_11, 
	    'xCleanupServiceclear_all_simulator_caches__mutmut_12': xCleanupServiceclear_all_simulator_caches__mutmut_12, 
	    'xCleanupServiceclear_all_simulator_caches__mutmut_13': xCleanupServiceclear_all_simulator_caches__mutmut_13, 
	    'xCleanupServiceclear_all_simulator_caches__mutmut_14': xCleanupServiceclear_all_simulator_caches__mutmut_14, 
	    'xCleanupServiceclear_all_simulator_caches__mutmut_15': xCleanupServiceclear_all_simulator_caches__mutmut_15, 
	    'xCleanupServiceclear_all_simulator_caches__mutmut_16': xCleanupServiceclear_all_simulator_caches__mutmut_16, 
	    'xCleanupServiceclear_all_simulator_caches__mutmut_17': xCleanupServiceclear_all_simulator_caches__mutmut_17, 
	    'xCleanupServiceclear_all_simulator_caches__mutmut_18': xCleanupServiceclear_all_simulator_caches__mutmut_18
	}
	
	def clear_all_simulator_caches(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupServiceclear_all_simulator_caches__mutmut_orig"), object.__getattribute__(self, "xCleanupServiceclear_all_simulator_caches__mutmut_mutants"), args, kwargs, self)
		return result 
	
	clear_all_simulator_caches.__signature__ = _mutmut_signature(xCleanupServiceclear_all_simulator_caches__mutmut_orig)
	xCleanupServiceclear_all_simulator_caches__mutmut_orig.__name__ = 'xCleanupServiceclear_all_simulator_caches'

	def xCleanupServicedisable_core_simulator_service__mutmut_orig(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["launchctl", "bootout", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_1(self) -> ActionResult:
		user_scope = None
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["launchctl", "bootout", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_2(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = None
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_3(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			None,
			[
				["launchctl", "bootout", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_4(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			None,
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_5(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["launchctl", "bootout", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=None,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_6(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			[
				["launchctl", "bootout", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_7(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_8(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["launchctl", "bootout", user_scope],
				["launchctl", "disable", user_scope],
			],
			)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_9(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"XXlaunchctl bootout + disable CoreSimulator serviceXX",
			[
				["launchctl", "bootout", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_10(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable coresimulator service",
			[
				["launchctl", "bootout", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_11(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"LAUNCHCTL BOOTOUT + DISABLE CORESIMULATOR SERVICE",
			[
				["launchctl", "bootout", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_12(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["XXlaunchctlXX", "bootout", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_13(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["LAUNCHCTL", "bootout", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_14(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["launchctl", "XXbootoutXX", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_15(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["launchctl", "BOOTOUT", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_16(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["launchctl", "bootout", user_scope],
				["XXlaunchctlXX", "disable", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_17(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["launchctl", "bootout", user_scope],
				["LAUNCHCTL", "disable", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_18(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["launchctl", "bootout", user_scope],
				["launchctl", "XXdisableXX", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_19(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["launchctl", "bootout", user_scope],
				["launchctl", "DISABLE", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_20(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["launchctl", "bootout", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=True,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_21(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["launchctl", "bootout", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=False,
		)
		error = None
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_22(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["launchctl", "bootout", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() and step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_23(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["launchctl", "bootout", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=None, steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_24(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["launchctl", "bootout", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=None, error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_25(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["launchctl", "bootout", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], error=None)

	def xCleanupServicedisable_core_simulator_service__mutmut_26(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["launchctl", "bootout", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(steps=[step], error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_27(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["launchctl", "bootout", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, error=error)

	def xCleanupServicedisable_core_simulator_service__mutmut_28(self) -> ActionResult:
		user_scope = f"gui/{os.getuid()}/com.apple.CoreSimulator.CoreSimulatorService"
		step = self._run_sudo_batch(
			"launchctl bootout + disable CoreSimulator service",
			[
				["launchctl", "bootout", user_scope],
				["launchctl", "disable", user_scope],
			],
			required=False,
		)
		error = None if step.ok else (step.result.stderr.strip() or step.result.stdout.strip())
		return ActionResult(commands_ok=step.ok, steps=[step], )
	
	xCleanupServicedisable_core_simulator_service__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupServicedisable_core_simulator_service__mutmut_1': xCleanupServicedisable_core_simulator_service__mutmut_1, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_2': xCleanupServicedisable_core_simulator_service__mutmut_2, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_3': xCleanupServicedisable_core_simulator_service__mutmut_3, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_4': xCleanupServicedisable_core_simulator_service__mutmut_4, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_5': xCleanupServicedisable_core_simulator_service__mutmut_5, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_6': xCleanupServicedisable_core_simulator_service__mutmut_6, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_7': xCleanupServicedisable_core_simulator_service__mutmut_7, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_8': xCleanupServicedisable_core_simulator_service__mutmut_8, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_9': xCleanupServicedisable_core_simulator_service__mutmut_9, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_10': xCleanupServicedisable_core_simulator_service__mutmut_10, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_11': xCleanupServicedisable_core_simulator_service__mutmut_11, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_12': xCleanupServicedisable_core_simulator_service__mutmut_12, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_13': xCleanupServicedisable_core_simulator_service__mutmut_13, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_14': xCleanupServicedisable_core_simulator_service__mutmut_14, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_15': xCleanupServicedisable_core_simulator_service__mutmut_15, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_16': xCleanupServicedisable_core_simulator_service__mutmut_16, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_17': xCleanupServicedisable_core_simulator_service__mutmut_17, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_18': xCleanupServicedisable_core_simulator_service__mutmut_18, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_19': xCleanupServicedisable_core_simulator_service__mutmut_19, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_20': xCleanupServicedisable_core_simulator_service__mutmut_20, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_21': xCleanupServicedisable_core_simulator_service__mutmut_21, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_22': xCleanupServicedisable_core_simulator_service__mutmut_22, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_23': xCleanupServicedisable_core_simulator_service__mutmut_23, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_24': xCleanupServicedisable_core_simulator_service__mutmut_24, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_25': xCleanupServicedisable_core_simulator_service__mutmut_25, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_26': xCleanupServicedisable_core_simulator_service__mutmut_26, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_27': xCleanupServicedisable_core_simulator_service__mutmut_27, 
	    'xCleanupServicedisable_core_simulator_service__mutmut_28': xCleanupServicedisable_core_simulator_service__mutmut_28
	}
	
	def disable_core_simulator_service(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupServicedisable_core_simulator_service__mutmut_orig"), object.__getattribute__(self, "xCleanupServicedisable_core_simulator_service__mutmut_mutants"), args, kwargs, self)
		return result 
	
	disable_core_simulator_service.__signature__ = _mutmut_signature(xCleanupServicedisable_core_simulator_service__mutmut_orig)
	xCleanupServicedisable_core_simulator_service__mutmut_orig.__name__ = 'xCleanupServicedisable_core_simulator_service'

	def xCleanupServiceis_xcode_running__mutmut_orig(self) -> bool:
		if self._runner.run(["pgrep", "-x", "Xcode"]).returncode == 0:
			return True
		return self._runner.run(["pgrep", "-x", "Simulator"]).returncode == 0

	def xCleanupServiceis_xcode_running__mutmut_1(self) -> bool:
		if self._runner.run(None).returncode == 0:
			return True
		return self._runner.run(["pgrep", "-x", "Simulator"]).returncode == 0

	def xCleanupServiceis_xcode_running__mutmut_2(self) -> bool:
		if self._runner.run(["XXpgrepXX", "-x", "Xcode"]).returncode == 0:
			return True
		return self._runner.run(["pgrep", "-x", "Simulator"]).returncode == 0

	def xCleanupServiceis_xcode_running__mutmut_3(self) -> bool:
		if self._runner.run(["PGREP", "-x", "Xcode"]).returncode == 0:
			return True
		return self._runner.run(["pgrep", "-x", "Simulator"]).returncode == 0

	def xCleanupServiceis_xcode_running__mutmut_4(self) -> bool:
		if self._runner.run(["pgrep", "XX-xXX", "Xcode"]).returncode == 0:
			return True
		return self._runner.run(["pgrep", "-x", "Simulator"]).returncode == 0

	def xCleanupServiceis_xcode_running__mutmut_5(self) -> bool:
		if self._runner.run(["pgrep", "-X", "Xcode"]).returncode == 0:
			return True
		return self._runner.run(["pgrep", "-x", "Simulator"]).returncode == 0

	def xCleanupServiceis_xcode_running__mutmut_6(self) -> bool:
		if self._runner.run(["pgrep", "-x", "XXXcodeXX"]).returncode == 0:
			return True
		return self._runner.run(["pgrep", "-x", "Simulator"]).returncode == 0

	def xCleanupServiceis_xcode_running__mutmut_7(self) -> bool:
		if self._runner.run(["pgrep", "-x", "xcode"]).returncode == 0:
			return True
		return self._runner.run(["pgrep", "-x", "Simulator"]).returncode == 0

	def xCleanupServiceis_xcode_running__mutmut_8(self) -> bool:
		if self._runner.run(["pgrep", "-x", "XCODE"]).returncode == 0:
			return True
		return self._runner.run(["pgrep", "-x", "Simulator"]).returncode == 0

	def xCleanupServiceis_xcode_running__mutmut_9(self) -> bool:
		if self._runner.run(["pgrep", "-x", "Xcode"]).returncode != 0:
			return True
		return self._runner.run(["pgrep", "-x", "Simulator"]).returncode == 0

	def xCleanupServiceis_xcode_running__mutmut_10(self) -> bool:
		if self._runner.run(["pgrep", "-x", "Xcode"]).returncode == 1:
			return True
		return self._runner.run(["pgrep", "-x", "Simulator"]).returncode == 0

	def xCleanupServiceis_xcode_running__mutmut_11(self) -> bool:
		if self._runner.run(["pgrep", "-x", "Xcode"]).returncode == 0:
			return False
		return self._runner.run(["pgrep", "-x", "Simulator"]).returncode == 0

	def xCleanupServiceis_xcode_running__mutmut_12(self) -> bool:
		if self._runner.run(["pgrep", "-x", "Xcode"]).returncode == 0:
			return True
		return self._runner.run(None).returncode == 0

	def xCleanupServiceis_xcode_running__mutmut_13(self) -> bool:
		if self._runner.run(["pgrep", "-x", "Xcode"]).returncode == 0:
			return True
		return self._runner.run(["XXpgrepXX", "-x", "Simulator"]).returncode == 0

	def xCleanupServiceis_xcode_running__mutmut_14(self) -> bool:
		if self._runner.run(["pgrep", "-x", "Xcode"]).returncode == 0:
			return True
		return self._runner.run(["PGREP", "-x", "Simulator"]).returncode == 0

	def xCleanupServiceis_xcode_running__mutmut_15(self) -> bool:
		if self._runner.run(["pgrep", "-x", "Xcode"]).returncode == 0:
			return True
		return self._runner.run(["pgrep", "XX-xXX", "Simulator"]).returncode == 0

	def xCleanupServiceis_xcode_running__mutmut_16(self) -> bool:
		if self._runner.run(["pgrep", "-x", "Xcode"]).returncode == 0:
			return True
		return self._runner.run(["pgrep", "-X", "Simulator"]).returncode == 0

	def xCleanupServiceis_xcode_running__mutmut_17(self) -> bool:
		if self._runner.run(["pgrep", "-x", "Xcode"]).returncode == 0:
			return True
		return self._runner.run(["pgrep", "-x", "XXSimulatorXX"]).returncode == 0

	def xCleanupServiceis_xcode_running__mutmut_18(self) -> bool:
		if self._runner.run(["pgrep", "-x", "Xcode"]).returncode == 0:
			return True
		return self._runner.run(["pgrep", "-x", "simulator"]).returncode == 0

	def xCleanupServiceis_xcode_running__mutmut_19(self) -> bool:
		if self._runner.run(["pgrep", "-x", "Xcode"]).returncode == 0:
			return True
		return self._runner.run(["pgrep", "-x", "SIMULATOR"]).returncode == 0

	def xCleanupServiceis_xcode_running__mutmut_20(self) -> bool:
		if self._runner.run(["pgrep", "-x", "Xcode"]).returncode == 0:
			return True
		return self._runner.run(["pgrep", "-x", "Simulator"]).returncode != 0

	def xCleanupServiceis_xcode_running__mutmut_21(self) -> bool:
		if self._runner.run(["pgrep", "-x", "Xcode"]).returncode == 0:
			return True
		return self._runner.run(["pgrep", "-x", "Simulator"]).returncode == 1
	
	xCleanupServiceis_xcode_running__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupServiceis_xcode_running__mutmut_1': xCleanupServiceis_xcode_running__mutmut_1, 
	    'xCleanupServiceis_xcode_running__mutmut_2': xCleanupServiceis_xcode_running__mutmut_2, 
	    'xCleanupServiceis_xcode_running__mutmut_3': xCleanupServiceis_xcode_running__mutmut_3, 
	    'xCleanupServiceis_xcode_running__mutmut_4': xCleanupServiceis_xcode_running__mutmut_4, 
	    'xCleanupServiceis_xcode_running__mutmut_5': xCleanupServiceis_xcode_running__mutmut_5, 
	    'xCleanupServiceis_xcode_running__mutmut_6': xCleanupServiceis_xcode_running__mutmut_6, 
	    'xCleanupServiceis_xcode_running__mutmut_7': xCleanupServiceis_xcode_running__mutmut_7, 
	    'xCleanupServiceis_xcode_running__mutmut_8': xCleanupServiceis_xcode_running__mutmut_8, 
	    'xCleanupServiceis_xcode_running__mutmut_9': xCleanupServiceis_xcode_running__mutmut_9, 
	    'xCleanupServiceis_xcode_running__mutmut_10': xCleanupServiceis_xcode_running__mutmut_10, 
	    'xCleanupServiceis_xcode_running__mutmut_11': xCleanupServiceis_xcode_running__mutmut_11, 
	    'xCleanupServiceis_xcode_running__mutmut_12': xCleanupServiceis_xcode_running__mutmut_12, 
	    'xCleanupServiceis_xcode_running__mutmut_13': xCleanupServiceis_xcode_running__mutmut_13, 
	    'xCleanupServiceis_xcode_running__mutmut_14': xCleanupServiceis_xcode_running__mutmut_14, 
	    'xCleanupServiceis_xcode_running__mutmut_15': xCleanupServiceis_xcode_running__mutmut_15, 
	    'xCleanupServiceis_xcode_running__mutmut_16': xCleanupServiceis_xcode_running__mutmut_16, 
	    'xCleanupServiceis_xcode_running__mutmut_17': xCleanupServiceis_xcode_running__mutmut_17, 
	    'xCleanupServiceis_xcode_running__mutmut_18': xCleanupServiceis_xcode_running__mutmut_18, 
	    'xCleanupServiceis_xcode_running__mutmut_19': xCleanupServiceis_xcode_running__mutmut_19, 
	    'xCleanupServiceis_xcode_running__mutmut_20': xCleanupServiceis_xcode_running__mutmut_20, 
	    'xCleanupServiceis_xcode_running__mutmut_21': xCleanupServiceis_xcode_running__mutmut_21
	}
	
	def is_xcode_running(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupServiceis_xcode_running__mutmut_orig"), object.__getattribute__(self, "xCleanupServiceis_xcode_running__mutmut_mutants"), args, kwargs, self)
		return result 
	
	is_xcode_running.__signature__ = _mutmut_signature(xCleanupServiceis_xcode_running__mutmut_orig)
	xCleanupServiceis_xcode_running__mutmut_orig.__name__ = 'xCleanupServiceis_xcode_running'

	def xCleanupServiceget_mounted_simulator_volumes__mutmut_orig(self) -> List[str]:
		result = self._runner.run(["hdiutil", "info"])
		mounts = []
		for line in result.stdout.splitlines():
			if "Simulator" in line and "/Library/Developer/CoreSimulator/Volumes" in line:
				mounts.append(line.strip())
		return mounts

	def xCleanupServiceget_mounted_simulator_volumes__mutmut_1(self) -> List[str]:
		result = None
		mounts = []
		for line in result.stdout.splitlines():
			if "Simulator" in line and "/Library/Developer/CoreSimulator/Volumes" in line:
				mounts.append(line.strip())
		return mounts

	def xCleanupServiceget_mounted_simulator_volumes__mutmut_2(self) -> List[str]:
		result = self._runner.run(None)
		mounts = []
		for line in result.stdout.splitlines():
			if "Simulator" in line and "/Library/Developer/CoreSimulator/Volumes" in line:
				mounts.append(line.strip())
		return mounts

	def xCleanupServiceget_mounted_simulator_volumes__mutmut_3(self) -> List[str]:
		result = self._runner.run(["XXhdiutilXX", "info"])
		mounts = []
		for line in result.stdout.splitlines():
			if "Simulator" in line and "/Library/Developer/CoreSimulator/Volumes" in line:
				mounts.append(line.strip())
		return mounts

	def xCleanupServiceget_mounted_simulator_volumes__mutmut_4(self) -> List[str]:
		result = self._runner.run(["HDIUTIL", "info"])
		mounts = []
		for line in result.stdout.splitlines():
			if "Simulator" in line and "/Library/Developer/CoreSimulator/Volumes" in line:
				mounts.append(line.strip())
		return mounts

	def xCleanupServiceget_mounted_simulator_volumes__mutmut_5(self) -> List[str]:
		result = self._runner.run(["hdiutil", "XXinfoXX"])
		mounts = []
		for line in result.stdout.splitlines():
			if "Simulator" in line and "/Library/Developer/CoreSimulator/Volumes" in line:
				mounts.append(line.strip())
		return mounts

	def xCleanupServiceget_mounted_simulator_volumes__mutmut_6(self) -> List[str]:
		result = self._runner.run(["hdiutil", "INFO"])
		mounts = []
		for line in result.stdout.splitlines():
			if "Simulator" in line and "/Library/Developer/CoreSimulator/Volumes" in line:
				mounts.append(line.strip())
		return mounts

	def xCleanupServiceget_mounted_simulator_volumes__mutmut_7(self) -> List[str]:
		result = self._runner.run(["hdiutil", "info"])
		mounts = None
		for line in result.stdout.splitlines():
			if "Simulator" in line and "/Library/Developer/CoreSimulator/Volumes" in line:
				mounts.append(line.strip())
		return mounts

	def xCleanupServiceget_mounted_simulator_volumes__mutmut_8(self) -> List[str]:
		result = self._runner.run(["hdiutil", "info"])
		mounts = []
		for line in result.stdout.splitlines():
			if "Simulator" in line or "/Library/Developer/CoreSimulator/Volumes" in line:
				mounts.append(line.strip())
		return mounts

	def xCleanupServiceget_mounted_simulator_volumes__mutmut_9(self) -> List[str]:
		result = self._runner.run(["hdiutil", "info"])
		mounts = []
		for line in result.stdout.splitlines():
			if "XXSimulatorXX" in line and "/Library/Developer/CoreSimulator/Volumes" in line:
				mounts.append(line.strip())
		return mounts

	def xCleanupServiceget_mounted_simulator_volumes__mutmut_10(self) -> List[str]:
		result = self._runner.run(["hdiutil", "info"])
		mounts = []
		for line in result.stdout.splitlines():
			if "simulator" in line and "/Library/Developer/CoreSimulator/Volumes" in line:
				mounts.append(line.strip())
		return mounts

	def xCleanupServiceget_mounted_simulator_volumes__mutmut_11(self) -> List[str]:
		result = self._runner.run(["hdiutil", "info"])
		mounts = []
		for line in result.stdout.splitlines():
			if "SIMULATOR" in line and "/Library/Developer/CoreSimulator/Volumes" in line:
				mounts.append(line.strip())
		return mounts

	def xCleanupServiceget_mounted_simulator_volumes__mutmut_12(self) -> List[str]:
		result = self._runner.run(["hdiutil", "info"])
		mounts = []
		for line in result.stdout.splitlines():
			if "Simulator" not in line and "/Library/Developer/CoreSimulator/Volumes" in line:
				mounts.append(line.strip())
		return mounts

	def xCleanupServiceget_mounted_simulator_volumes__mutmut_13(self) -> List[str]:
		result = self._runner.run(["hdiutil", "info"])
		mounts = []
		for line in result.stdout.splitlines():
			if "Simulator" in line and "XX/Library/Developer/CoreSimulator/VolumesXX" in line:
				mounts.append(line.strip())
		return mounts

	def xCleanupServiceget_mounted_simulator_volumes__mutmut_14(self) -> List[str]:
		result = self._runner.run(["hdiutil", "info"])
		mounts = []
		for line in result.stdout.splitlines():
			if "Simulator" in line and "/library/developer/coresimulator/volumes" in line:
				mounts.append(line.strip())
		return mounts

	def xCleanupServiceget_mounted_simulator_volumes__mutmut_15(self) -> List[str]:
		result = self._runner.run(["hdiutil", "info"])
		mounts = []
		for line in result.stdout.splitlines():
			if "Simulator" in line and "/LIBRARY/DEVELOPER/CORESIMULATOR/VOLUMES" in line:
				mounts.append(line.strip())
		return mounts

	def xCleanupServiceget_mounted_simulator_volumes__mutmut_16(self) -> List[str]:
		result = self._runner.run(["hdiutil", "info"])
		mounts = []
		for line in result.stdout.splitlines():
			if "Simulator" in line and "/Library/Developer/CoreSimulator/Volumes" not in line:
				mounts.append(line.strip())
		return mounts

	def xCleanupServiceget_mounted_simulator_volumes__mutmut_17(self) -> List[str]:
		result = self._runner.run(["hdiutil", "info"])
		mounts = []
		for line in result.stdout.splitlines():
			if "Simulator" in line and "/Library/Developer/CoreSimulator/Volumes" in line:
				mounts.append(None)
		return mounts
	
	xCleanupServiceget_mounted_simulator_volumes__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupServiceget_mounted_simulator_volumes__mutmut_1': xCleanupServiceget_mounted_simulator_volumes__mutmut_1, 
	    'xCleanupServiceget_mounted_simulator_volumes__mutmut_2': xCleanupServiceget_mounted_simulator_volumes__mutmut_2, 
	    'xCleanupServiceget_mounted_simulator_volumes__mutmut_3': xCleanupServiceget_mounted_simulator_volumes__mutmut_3, 
	    'xCleanupServiceget_mounted_simulator_volumes__mutmut_4': xCleanupServiceget_mounted_simulator_volumes__mutmut_4, 
	    'xCleanupServiceget_mounted_simulator_volumes__mutmut_5': xCleanupServiceget_mounted_simulator_volumes__mutmut_5, 
	    'xCleanupServiceget_mounted_simulator_volumes__mutmut_6': xCleanupServiceget_mounted_simulator_volumes__mutmut_6, 
	    'xCleanupServiceget_mounted_simulator_volumes__mutmut_7': xCleanupServiceget_mounted_simulator_volumes__mutmut_7, 
	    'xCleanupServiceget_mounted_simulator_volumes__mutmut_8': xCleanupServiceget_mounted_simulator_volumes__mutmut_8, 
	    'xCleanupServiceget_mounted_simulator_volumes__mutmut_9': xCleanupServiceget_mounted_simulator_volumes__mutmut_9, 
	    'xCleanupServiceget_mounted_simulator_volumes__mutmut_10': xCleanupServiceget_mounted_simulator_volumes__mutmut_10, 
	    'xCleanupServiceget_mounted_simulator_volumes__mutmut_11': xCleanupServiceget_mounted_simulator_volumes__mutmut_11, 
	    'xCleanupServiceget_mounted_simulator_volumes__mutmut_12': xCleanupServiceget_mounted_simulator_volumes__mutmut_12, 
	    'xCleanupServiceget_mounted_simulator_volumes__mutmut_13': xCleanupServiceget_mounted_simulator_volumes__mutmut_13, 
	    'xCleanupServiceget_mounted_simulator_volumes__mutmut_14': xCleanupServiceget_mounted_simulator_volumes__mutmut_14, 
	    'xCleanupServiceget_mounted_simulator_volumes__mutmut_15': xCleanupServiceget_mounted_simulator_volumes__mutmut_15, 
	    'xCleanupServiceget_mounted_simulator_volumes__mutmut_16': xCleanupServiceget_mounted_simulator_volumes__mutmut_16, 
	    'xCleanupServiceget_mounted_simulator_volumes__mutmut_17': xCleanupServiceget_mounted_simulator_volumes__mutmut_17
	}
	
	def get_mounted_simulator_volumes(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupServiceget_mounted_simulator_volumes__mutmut_orig"), object.__getattribute__(self, "xCleanupServiceget_mounted_simulator_volumes__mutmut_mutants"), args, kwargs, self)
		return result 
	
	get_mounted_simulator_volumes.__signature__ = _mutmut_signature(xCleanupServiceget_mounted_simulator_volumes__mutmut_orig)
	xCleanupServiceget_mounted_simulator_volumes__mutmut_orig.__name__ = 'xCleanupServiceget_mounted_simulator_volumes'

	def xCleanupService_get_parent_disk__mutmut_orig(self, slice_device: str) -> str:
		device = slice_device
		if device.startswith("disk"):
			device = f"/dev/{device}"
		match = re.match(r"(/dev/disk\d+)", device)
		if match:
			return match.group(1)
		return device

	def xCleanupService_get_parent_disk__mutmut_1(self, slice_device: str) -> str:
		device = None
		if device.startswith("disk"):
			device = f"/dev/{device}"
		match = re.match(r"(/dev/disk\d+)", device)
		if match:
			return match.group(1)
		return device

	def xCleanupService_get_parent_disk__mutmut_2(self, slice_device: str) -> str:
		device = slice_device
		if device.startswith(None):
			device = f"/dev/{device}"
		match = re.match(r"(/dev/disk\d+)", device)
		if match:
			return match.group(1)
		return device

	def xCleanupService_get_parent_disk__mutmut_3(self, slice_device: str) -> str:
		device = slice_device
		if device.startswith("XXdiskXX"):
			device = f"/dev/{device}"
		match = re.match(r"(/dev/disk\d+)", device)
		if match:
			return match.group(1)
		return device

	def xCleanupService_get_parent_disk__mutmut_4(self, slice_device: str) -> str:
		device = slice_device
		if device.startswith("DISK"):
			device = f"/dev/{device}"
		match = re.match(r"(/dev/disk\d+)", device)
		if match:
			return match.group(1)
		return device

	def xCleanupService_get_parent_disk__mutmut_5(self, slice_device: str) -> str:
		device = slice_device
		if device.startswith("disk"):
			device = None
		match = re.match(r"(/dev/disk\d+)", device)
		if match:
			return match.group(1)
		return device

	def xCleanupService_get_parent_disk__mutmut_6(self, slice_device: str) -> str:
		device = slice_device
		if device.startswith("disk"):
			device = f"/dev/{device}"
		match = None
		if match:
			return match.group(1)
		return device

	def xCleanupService_get_parent_disk__mutmut_7(self, slice_device: str) -> str:
		device = slice_device
		if device.startswith("disk"):
			device = f"/dev/{device}"
		match = re.match(None, device)
		if match:
			return match.group(1)
		return device

	def xCleanupService_get_parent_disk__mutmut_8(self, slice_device: str) -> str:
		device = slice_device
		if device.startswith("disk"):
			device = f"/dev/{device}"
		match = re.match(r"(/dev/disk\d+)", None)
		if match:
			return match.group(1)
		return device

	def xCleanupService_get_parent_disk__mutmut_9(self, slice_device: str) -> str:
		device = slice_device
		if device.startswith("disk"):
			device = f"/dev/{device}"
		match = re.match(device)
		if match:
			return match.group(1)
		return device

	def xCleanupService_get_parent_disk__mutmut_10(self, slice_device: str) -> str:
		device = slice_device
		if device.startswith("disk"):
			device = f"/dev/{device}"
		match = re.match(r"(/dev/disk\d+)", )
		if match:
			return match.group(1)
		return device

	def xCleanupService_get_parent_disk__mutmut_11(self, slice_device: str) -> str:
		device = slice_device
		if device.startswith("disk"):
			device = f"/dev/{device}"
		match = re.match(r"XX(/dev/disk\d+)XX", device)
		if match:
			return match.group(1)
		return device

	def xCleanupService_get_parent_disk__mutmut_12(self, slice_device: str) -> str:
		device = slice_device
		if device.startswith("disk"):
			device = f"/dev/{device}"
		match = re.match(r"(/DEV/DISK\d+)", device)
		if match:
			return match.group(1)
		return device

	def xCleanupService_get_parent_disk__mutmut_13(self, slice_device: str) -> str:
		device = slice_device
		if device.startswith("disk"):
			device = f"/dev/{device}"
		match = re.match(r"(/dev/disk\d+)", device)
		if match:
			return match.group(None)
		return device

	def xCleanupService_get_parent_disk__mutmut_14(self, slice_device: str) -> str:
		device = slice_device
		if device.startswith("disk"):
			device = f"/dev/{device}"
		match = re.match(r"(/dev/disk\d+)", device)
		if match:
			return match.group(2)
		return device
	
	xCleanupService_get_parent_disk__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupService_get_parent_disk__mutmut_1': xCleanupService_get_parent_disk__mutmut_1, 
	    'xCleanupService_get_parent_disk__mutmut_2': xCleanupService_get_parent_disk__mutmut_2, 
	    'xCleanupService_get_parent_disk__mutmut_3': xCleanupService_get_parent_disk__mutmut_3, 
	    'xCleanupService_get_parent_disk__mutmut_4': xCleanupService_get_parent_disk__mutmut_4, 
	    'xCleanupService_get_parent_disk__mutmut_5': xCleanupService_get_parent_disk__mutmut_5, 
	    'xCleanupService_get_parent_disk__mutmut_6': xCleanupService_get_parent_disk__mutmut_6, 
	    'xCleanupService_get_parent_disk__mutmut_7': xCleanupService_get_parent_disk__mutmut_7, 
	    'xCleanupService_get_parent_disk__mutmut_8': xCleanupService_get_parent_disk__mutmut_8, 
	    'xCleanupService_get_parent_disk__mutmut_9': xCleanupService_get_parent_disk__mutmut_9, 
	    'xCleanupService_get_parent_disk__mutmut_10': xCleanupService_get_parent_disk__mutmut_10, 
	    'xCleanupService_get_parent_disk__mutmut_11': xCleanupService_get_parent_disk__mutmut_11, 
	    'xCleanupService_get_parent_disk__mutmut_12': xCleanupService_get_parent_disk__mutmut_12, 
	    'xCleanupService_get_parent_disk__mutmut_13': xCleanupService_get_parent_disk__mutmut_13, 
	    'xCleanupService_get_parent_disk__mutmut_14': xCleanupService_get_parent_disk__mutmut_14
	}
	
	def _get_parent_disk(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupService_get_parent_disk__mutmut_orig"), object.__getattribute__(self, "xCleanupService_get_parent_disk__mutmut_mutants"), args, kwargs, self)
		return result 
	
	_get_parent_disk.__signature__ = _mutmut_signature(xCleanupService_get_parent_disk__mutmut_orig)
	xCleanupService_get_parent_disk__mutmut_orig.__name__ = 'xCleanupService_get_parent_disk'

	def xCleanupServiceunmount_simulator_disk__mutmut_orig(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_1(self, device: str) -> ActionResult:
		parent = None
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_2(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(None)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_3(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = None
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_4(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = None
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_5(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			None,
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_6(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			None,
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_7(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=None,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_8(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=None,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_9(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_10(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_11(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_12(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_13(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["XXdiskutilXX", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_14(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["DISKUTIL", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_15(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "XXunmountDiskXX", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_16(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountdisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_17(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "UNMOUNTDISK", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_18(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "XXforceXX", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_19(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "FORCE", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_20(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=True,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_21(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=False,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_22(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(None)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_23(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=None, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_24(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=None, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_25(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_26(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_27(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, )

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_28(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=False, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_29(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = None
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_30(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			None,
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_31(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			None,
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_32(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=None,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_33(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=None,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_34(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_35(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_36(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_37(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_38(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["XXhdiutilXX", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_39(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["HDIUTIL", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_40(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "XXdetachXX", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_41(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "DETACH", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_42(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "XX-forceXX"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_43(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-FORCE"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_44(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=True,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_45(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=False,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_46(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(None)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_47(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = None
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_48(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(None)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_49(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = ""
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_50(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = None
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_51(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[+1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_52(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-2].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_53(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(None, 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_54(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), None, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_55(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, None, "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_56(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", None)
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_57(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_58(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_59(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_60(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", )
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_61(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 2, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_62(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "XXXX", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_63(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "XXunmount failedXX")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_64(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "UNMOUNT FAILED")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_65(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = None
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_66(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() and "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_67(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() and last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_68(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "XXunmount failedXX"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_69(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "UNMOUNT FAILED"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_70(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=None, steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_71(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=None, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_72(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, error=None)

	def xCleanupServiceunmount_simulator_disk__mutmut_73(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(steps=steps, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_74(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, error=error)

	def xCleanupServiceunmount_simulator_disk__mutmut_75(self, device: str) -> ActionResult:
		parent = self._get_parent_disk(device)
		steps: List[StepResult] = []
		step = self._run_step(
			f"diskutil unmountDisk force {parent}",
			["diskutil", "unmountDisk", "force", parent],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(step)
		if step.ok:
			return ActionResult(commands_ok=True, steps=steps, error=None)

		fallback = self._run_step(
			f"hdiutil detach {parent}",
			["hdiutil", "detach", parent, "-force"],
			required=False,
			allow_not_mounted=True,
		)
		steps.append(fallback)
		commands_ok = any(step.ok for step in steps)
		if commands_ok:
			error = None
		else:
			last = steps[-1].result if steps else CmdResult(tuple(), 1, "", "unmount failed")
			error = last.stderr.strip() or last.stdout.strip() or "unmount failed"
		return ActionResult(commands_ok=commands_ok, steps=steps, )
	
	xCleanupServiceunmount_simulator_disk__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupServiceunmount_simulator_disk__mutmut_1': xCleanupServiceunmount_simulator_disk__mutmut_1, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_2': xCleanupServiceunmount_simulator_disk__mutmut_2, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_3': xCleanupServiceunmount_simulator_disk__mutmut_3, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_4': xCleanupServiceunmount_simulator_disk__mutmut_4, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_5': xCleanupServiceunmount_simulator_disk__mutmut_5, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_6': xCleanupServiceunmount_simulator_disk__mutmut_6, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_7': xCleanupServiceunmount_simulator_disk__mutmut_7, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_8': xCleanupServiceunmount_simulator_disk__mutmut_8, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_9': xCleanupServiceunmount_simulator_disk__mutmut_9, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_10': xCleanupServiceunmount_simulator_disk__mutmut_10, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_11': xCleanupServiceunmount_simulator_disk__mutmut_11, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_12': xCleanupServiceunmount_simulator_disk__mutmut_12, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_13': xCleanupServiceunmount_simulator_disk__mutmut_13, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_14': xCleanupServiceunmount_simulator_disk__mutmut_14, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_15': xCleanupServiceunmount_simulator_disk__mutmut_15, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_16': xCleanupServiceunmount_simulator_disk__mutmut_16, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_17': xCleanupServiceunmount_simulator_disk__mutmut_17, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_18': xCleanupServiceunmount_simulator_disk__mutmut_18, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_19': xCleanupServiceunmount_simulator_disk__mutmut_19, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_20': xCleanupServiceunmount_simulator_disk__mutmut_20, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_21': xCleanupServiceunmount_simulator_disk__mutmut_21, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_22': xCleanupServiceunmount_simulator_disk__mutmut_22, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_23': xCleanupServiceunmount_simulator_disk__mutmut_23, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_24': xCleanupServiceunmount_simulator_disk__mutmut_24, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_25': xCleanupServiceunmount_simulator_disk__mutmut_25, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_26': xCleanupServiceunmount_simulator_disk__mutmut_26, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_27': xCleanupServiceunmount_simulator_disk__mutmut_27, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_28': xCleanupServiceunmount_simulator_disk__mutmut_28, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_29': xCleanupServiceunmount_simulator_disk__mutmut_29, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_30': xCleanupServiceunmount_simulator_disk__mutmut_30, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_31': xCleanupServiceunmount_simulator_disk__mutmut_31, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_32': xCleanupServiceunmount_simulator_disk__mutmut_32, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_33': xCleanupServiceunmount_simulator_disk__mutmut_33, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_34': xCleanupServiceunmount_simulator_disk__mutmut_34, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_35': xCleanupServiceunmount_simulator_disk__mutmut_35, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_36': xCleanupServiceunmount_simulator_disk__mutmut_36, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_37': xCleanupServiceunmount_simulator_disk__mutmut_37, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_38': xCleanupServiceunmount_simulator_disk__mutmut_38, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_39': xCleanupServiceunmount_simulator_disk__mutmut_39, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_40': xCleanupServiceunmount_simulator_disk__mutmut_40, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_41': xCleanupServiceunmount_simulator_disk__mutmut_41, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_42': xCleanupServiceunmount_simulator_disk__mutmut_42, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_43': xCleanupServiceunmount_simulator_disk__mutmut_43, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_44': xCleanupServiceunmount_simulator_disk__mutmut_44, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_45': xCleanupServiceunmount_simulator_disk__mutmut_45, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_46': xCleanupServiceunmount_simulator_disk__mutmut_46, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_47': xCleanupServiceunmount_simulator_disk__mutmut_47, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_48': xCleanupServiceunmount_simulator_disk__mutmut_48, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_49': xCleanupServiceunmount_simulator_disk__mutmut_49, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_50': xCleanupServiceunmount_simulator_disk__mutmut_50, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_51': xCleanupServiceunmount_simulator_disk__mutmut_51, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_52': xCleanupServiceunmount_simulator_disk__mutmut_52, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_53': xCleanupServiceunmount_simulator_disk__mutmut_53, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_54': xCleanupServiceunmount_simulator_disk__mutmut_54, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_55': xCleanupServiceunmount_simulator_disk__mutmut_55, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_56': xCleanupServiceunmount_simulator_disk__mutmut_56, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_57': xCleanupServiceunmount_simulator_disk__mutmut_57, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_58': xCleanupServiceunmount_simulator_disk__mutmut_58, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_59': xCleanupServiceunmount_simulator_disk__mutmut_59, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_60': xCleanupServiceunmount_simulator_disk__mutmut_60, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_61': xCleanupServiceunmount_simulator_disk__mutmut_61, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_62': xCleanupServiceunmount_simulator_disk__mutmut_62, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_63': xCleanupServiceunmount_simulator_disk__mutmut_63, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_64': xCleanupServiceunmount_simulator_disk__mutmut_64, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_65': xCleanupServiceunmount_simulator_disk__mutmut_65, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_66': xCleanupServiceunmount_simulator_disk__mutmut_66, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_67': xCleanupServiceunmount_simulator_disk__mutmut_67, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_68': xCleanupServiceunmount_simulator_disk__mutmut_68, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_69': xCleanupServiceunmount_simulator_disk__mutmut_69, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_70': xCleanupServiceunmount_simulator_disk__mutmut_70, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_71': xCleanupServiceunmount_simulator_disk__mutmut_71, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_72': xCleanupServiceunmount_simulator_disk__mutmut_72, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_73': xCleanupServiceunmount_simulator_disk__mutmut_73, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_74': xCleanupServiceunmount_simulator_disk__mutmut_74, 
	    'xCleanupServiceunmount_simulator_disk__mutmut_75': xCleanupServiceunmount_simulator_disk__mutmut_75
	}
	
	def unmount_simulator_disk(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupServiceunmount_simulator_disk__mutmut_orig"), object.__getattribute__(self, "xCleanupServiceunmount_simulator_disk__mutmut_mutants"), args, kwargs, self)
		return result 
	
	unmount_simulator_disk.__signature__ = _mutmut_signature(xCleanupServiceunmount_simulator_disk__mutmut_orig)
	xCleanupServiceunmount_simulator_disk__mutmut_orig.__name__ = 'xCleanupServiceunmount_simulator_disk'

	def xCleanupService_unmount_simulator_volumes__mutmut_orig(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_1(self) -> List[StepResult]:
		results: List[StepResult] = None
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_2(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = None
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_3(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(None)
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_4(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(None))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_5(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = None

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_6(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(None)

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_7(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(None))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_8(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = None
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_9(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = None
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_10(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				None,
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_11(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				None,
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_12(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=None,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_13(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_14(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_15(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_16(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["XXdfXX", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_17(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["DF", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_18(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=True,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_19(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(None)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_20(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode == 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_21(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 1:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_22(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				break

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_23(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = None
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_24(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) <= 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_25(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 3:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_26(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				break
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_27(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = None
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_28(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[2].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_29(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[1]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_30(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = None
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_31(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(None)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_32(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent not in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_33(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				break

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_34(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = None
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_35(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(None)
			results.extend(unmount_result.steps)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_36(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(None)
			unmounted_parents.add(parent)

		return results

	def xCleanupService_unmount_simulator_volumes__mutmut_37(self) -> List[StepResult]:
		results: List[StepResult] = []
		volume_paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			volume_paths.extend(glob.glob(pattern))
		volume_paths = sorted(set(volume_paths))

		unmounted_parents = set()
		for vol_path in volume_paths:
			df_step = self._run_step(
				f"df {vol_path}",
				["df", vol_path],
				required=False,
			)
			results.append(df_step)
			if df_step.result.returncode != 0:
				continue

			lines = [ln for ln in df_step.result.stdout.splitlines() if ln.strip()]
			if len(lines) < 2:
				continue
			device = lines[1].split()[0]
			parent = self._get_parent_disk(device)
			if parent in unmounted_parents:
				continue

			unmount_result = self.unmount_simulator_disk(device)
			results.extend(unmount_result.steps)
			unmounted_parents.add(None)

		return results
	
	xCleanupService_unmount_simulator_volumes__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupService_unmount_simulator_volumes__mutmut_1': xCleanupService_unmount_simulator_volumes__mutmut_1, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_2': xCleanupService_unmount_simulator_volumes__mutmut_2, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_3': xCleanupService_unmount_simulator_volumes__mutmut_3, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_4': xCleanupService_unmount_simulator_volumes__mutmut_4, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_5': xCleanupService_unmount_simulator_volumes__mutmut_5, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_6': xCleanupService_unmount_simulator_volumes__mutmut_6, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_7': xCleanupService_unmount_simulator_volumes__mutmut_7, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_8': xCleanupService_unmount_simulator_volumes__mutmut_8, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_9': xCleanupService_unmount_simulator_volumes__mutmut_9, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_10': xCleanupService_unmount_simulator_volumes__mutmut_10, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_11': xCleanupService_unmount_simulator_volumes__mutmut_11, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_12': xCleanupService_unmount_simulator_volumes__mutmut_12, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_13': xCleanupService_unmount_simulator_volumes__mutmut_13, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_14': xCleanupService_unmount_simulator_volumes__mutmut_14, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_15': xCleanupService_unmount_simulator_volumes__mutmut_15, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_16': xCleanupService_unmount_simulator_volumes__mutmut_16, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_17': xCleanupService_unmount_simulator_volumes__mutmut_17, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_18': xCleanupService_unmount_simulator_volumes__mutmut_18, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_19': xCleanupService_unmount_simulator_volumes__mutmut_19, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_20': xCleanupService_unmount_simulator_volumes__mutmut_20, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_21': xCleanupService_unmount_simulator_volumes__mutmut_21, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_22': xCleanupService_unmount_simulator_volumes__mutmut_22, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_23': xCleanupService_unmount_simulator_volumes__mutmut_23, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_24': xCleanupService_unmount_simulator_volumes__mutmut_24, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_25': xCleanupService_unmount_simulator_volumes__mutmut_25, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_26': xCleanupService_unmount_simulator_volumes__mutmut_26, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_27': xCleanupService_unmount_simulator_volumes__mutmut_27, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_28': xCleanupService_unmount_simulator_volumes__mutmut_28, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_29': xCleanupService_unmount_simulator_volumes__mutmut_29, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_30': xCleanupService_unmount_simulator_volumes__mutmut_30, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_31': xCleanupService_unmount_simulator_volumes__mutmut_31, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_32': xCleanupService_unmount_simulator_volumes__mutmut_32, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_33': xCleanupService_unmount_simulator_volumes__mutmut_33, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_34': xCleanupService_unmount_simulator_volumes__mutmut_34, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_35': xCleanupService_unmount_simulator_volumes__mutmut_35, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_36': xCleanupService_unmount_simulator_volumes__mutmut_36, 
	    'xCleanupService_unmount_simulator_volumes__mutmut_37': xCleanupService_unmount_simulator_volumes__mutmut_37
	}
	
	def _unmount_simulator_volumes(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupService_unmount_simulator_volumes__mutmut_orig"), object.__getattribute__(self, "xCleanupService_unmount_simulator_volumes__mutmut_mutants"), args, kwargs, self)
		return result 
	
	_unmount_simulator_volumes.__signature__ = _mutmut_signature(xCleanupService_unmount_simulator_volumes__mutmut_orig)
	xCleanupService_unmount_simulator_volumes__mutmut_orig.__name__ = 'xCleanupService_unmount_simulator_volumes'

	def xCleanupService_remove_runtime_directories__mutmut_orig(self) -> List[StepResult]:
		paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			paths.extend(glob.glob(pattern))
		paths.append(CRYP_TEX_PATH)

		commands = [["rm", "-rf", path] for path in paths]
		step = self._run_sudo_batch("rm -rf simulator runtime directories", commands, required=True)
		return [step]

	def xCleanupService_remove_runtime_directories__mutmut_1(self) -> List[StepResult]:
		paths: List[str] = None
		for pattern in RUNTIME_GLOBS:
			paths.extend(glob.glob(pattern))
		paths.append(CRYP_TEX_PATH)

		commands = [["rm", "-rf", path] for path in paths]
		step = self._run_sudo_batch("rm -rf simulator runtime directories", commands, required=True)
		return [step]

	def xCleanupService_remove_runtime_directories__mutmut_2(self) -> List[StepResult]:
		paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			paths.extend(None)
		paths.append(CRYP_TEX_PATH)

		commands = [["rm", "-rf", path] for path in paths]
		step = self._run_sudo_batch("rm -rf simulator runtime directories", commands, required=True)
		return [step]

	def xCleanupService_remove_runtime_directories__mutmut_3(self) -> List[StepResult]:
		paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			paths.extend(glob.glob(None))
		paths.append(CRYP_TEX_PATH)

		commands = [["rm", "-rf", path] for path in paths]
		step = self._run_sudo_batch("rm -rf simulator runtime directories", commands, required=True)
		return [step]

	def xCleanupService_remove_runtime_directories__mutmut_4(self) -> List[StepResult]:
		paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			paths.extend(glob.glob(pattern))
		paths.append(None)

		commands = [["rm", "-rf", path] for path in paths]
		step = self._run_sudo_batch("rm -rf simulator runtime directories", commands, required=True)
		return [step]

	def xCleanupService_remove_runtime_directories__mutmut_5(self) -> List[StepResult]:
		paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			paths.extend(glob.glob(pattern))
		paths.append(CRYP_TEX_PATH)

		commands = None
		step = self._run_sudo_batch("rm -rf simulator runtime directories", commands, required=True)
		return [step]

	def xCleanupService_remove_runtime_directories__mutmut_6(self) -> List[StepResult]:
		paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			paths.extend(glob.glob(pattern))
		paths.append(CRYP_TEX_PATH)

		commands = [["XXrmXX", "-rf", path] for path in paths]
		step = self._run_sudo_batch("rm -rf simulator runtime directories", commands, required=True)
		return [step]

	def xCleanupService_remove_runtime_directories__mutmut_7(self) -> List[StepResult]:
		paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			paths.extend(glob.glob(pattern))
		paths.append(CRYP_TEX_PATH)

		commands = [["RM", "-rf", path] for path in paths]
		step = self._run_sudo_batch("rm -rf simulator runtime directories", commands, required=True)
		return [step]

	def xCleanupService_remove_runtime_directories__mutmut_8(self) -> List[StepResult]:
		paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			paths.extend(glob.glob(pattern))
		paths.append(CRYP_TEX_PATH)

		commands = [["rm", "XX-rfXX", path] for path in paths]
		step = self._run_sudo_batch("rm -rf simulator runtime directories", commands, required=True)
		return [step]

	def xCleanupService_remove_runtime_directories__mutmut_9(self) -> List[StepResult]:
		paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			paths.extend(glob.glob(pattern))
		paths.append(CRYP_TEX_PATH)

		commands = [["rm", "-RF", path] for path in paths]
		step = self._run_sudo_batch("rm -rf simulator runtime directories", commands, required=True)
		return [step]

	def xCleanupService_remove_runtime_directories__mutmut_10(self) -> List[StepResult]:
		paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			paths.extend(glob.glob(pattern))
		paths.append(CRYP_TEX_PATH)

		commands = [["rm", "-rf", path] for path in paths]
		step = None
		return [step]

	def xCleanupService_remove_runtime_directories__mutmut_11(self) -> List[StepResult]:
		paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			paths.extend(glob.glob(pattern))
		paths.append(CRYP_TEX_PATH)

		commands = [["rm", "-rf", path] for path in paths]
		step = self._run_sudo_batch(None, commands, required=True)
		return [step]

	def xCleanupService_remove_runtime_directories__mutmut_12(self) -> List[StepResult]:
		paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			paths.extend(glob.glob(pattern))
		paths.append(CRYP_TEX_PATH)

		commands = [["rm", "-rf", path] for path in paths]
		step = self._run_sudo_batch("rm -rf simulator runtime directories", None, required=True)
		return [step]

	def xCleanupService_remove_runtime_directories__mutmut_13(self) -> List[StepResult]:
		paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			paths.extend(glob.glob(pattern))
		paths.append(CRYP_TEX_PATH)

		commands = [["rm", "-rf", path] for path in paths]
		step = self._run_sudo_batch("rm -rf simulator runtime directories", commands, required=None)
		return [step]

	def xCleanupService_remove_runtime_directories__mutmut_14(self) -> List[StepResult]:
		paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			paths.extend(glob.glob(pattern))
		paths.append(CRYP_TEX_PATH)

		commands = [["rm", "-rf", path] for path in paths]
		step = self._run_sudo_batch(commands, required=True)
		return [step]

	def xCleanupService_remove_runtime_directories__mutmut_15(self) -> List[StepResult]:
		paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			paths.extend(glob.glob(pattern))
		paths.append(CRYP_TEX_PATH)

		commands = [["rm", "-rf", path] for path in paths]
		step = self._run_sudo_batch("rm -rf simulator runtime directories", required=True)
		return [step]

	def xCleanupService_remove_runtime_directories__mutmut_16(self) -> List[StepResult]:
		paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			paths.extend(glob.glob(pattern))
		paths.append(CRYP_TEX_PATH)

		commands = [["rm", "-rf", path] for path in paths]
		step = self._run_sudo_batch("rm -rf simulator runtime directories", commands, )
		return [step]

	def xCleanupService_remove_runtime_directories__mutmut_17(self) -> List[StepResult]:
		paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			paths.extend(glob.glob(pattern))
		paths.append(CRYP_TEX_PATH)

		commands = [["rm", "-rf", path] for path in paths]
		step = self._run_sudo_batch("XXrm -rf simulator runtime directoriesXX", commands, required=True)
		return [step]

	def xCleanupService_remove_runtime_directories__mutmut_18(self) -> List[StepResult]:
		paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			paths.extend(glob.glob(pattern))
		paths.append(CRYP_TEX_PATH)

		commands = [["rm", "-rf", path] for path in paths]
		step = self._run_sudo_batch("RM -RF SIMULATOR RUNTIME DIRECTORIES", commands, required=True)
		return [step]

	def xCleanupService_remove_runtime_directories__mutmut_19(self) -> List[StepResult]:
		paths: List[str] = []
		for pattern in RUNTIME_GLOBS:
			paths.extend(glob.glob(pattern))
		paths.append(CRYP_TEX_PATH)

		commands = [["rm", "-rf", path] for path in paths]
		step = self._run_sudo_batch("rm -rf simulator runtime directories", commands, required=False)
		return [step]
	
	xCleanupService_remove_runtime_directories__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupService_remove_runtime_directories__mutmut_1': xCleanupService_remove_runtime_directories__mutmut_1, 
	    'xCleanupService_remove_runtime_directories__mutmut_2': xCleanupService_remove_runtime_directories__mutmut_2, 
	    'xCleanupService_remove_runtime_directories__mutmut_3': xCleanupService_remove_runtime_directories__mutmut_3, 
	    'xCleanupService_remove_runtime_directories__mutmut_4': xCleanupService_remove_runtime_directories__mutmut_4, 
	    'xCleanupService_remove_runtime_directories__mutmut_5': xCleanupService_remove_runtime_directories__mutmut_5, 
	    'xCleanupService_remove_runtime_directories__mutmut_6': xCleanupService_remove_runtime_directories__mutmut_6, 
	    'xCleanupService_remove_runtime_directories__mutmut_7': xCleanupService_remove_runtime_directories__mutmut_7, 
	    'xCleanupService_remove_runtime_directories__mutmut_8': xCleanupService_remove_runtime_directories__mutmut_8, 
	    'xCleanupService_remove_runtime_directories__mutmut_9': xCleanupService_remove_runtime_directories__mutmut_9, 
	    'xCleanupService_remove_runtime_directories__mutmut_10': xCleanupService_remove_runtime_directories__mutmut_10, 
	    'xCleanupService_remove_runtime_directories__mutmut_11': xCleanupService_remove_runtime_directories__mutmut_11, 
	    'xCleanupService_remove_runtime_directories__mutmut_12': xCleanupService_remove_runtime_directories__mutmut_12, 
	    'xCleanupService_remove_runtime_directories__mutmut_13': xCleanupService_remove_runtime_directories__mutmut_13, 
	    'xCleanupService_remove_runtime_directories__mutmut_14': xCleanupService_remove_runtime_directories__mutmut_14, 
	    'xCleanupService_remove_runtime_directories__mutmut_15': xCleanupService_remove_runtime_directories__mutmut_15, 
	    'xCleanupService_remove_runtime_directories__mutmut_16': xCleanupService_remove_runtime_directories__mutmut_16, 
	    'xCleanupService_remove_runtime_directories__mutmut_17': xCleanupService_remove_runtime_directories__mutmut_17, 
	    'xCleanupService_remove_runtime_directories__mutmut_18': xCleanupService_remove_runtime_directories__mutmut_18, 
	    'xCleanupService_remove_runtime_directories__mutmut_19': xCleanupService_remove_runtime_directories__mutmut_19
	}
	
	def _remove_runtime_directories(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupService_remove_runtime_directories__mutmut_orig"), object.__getattribute__(self, "xCleanupService_remove_runtime_directories__mutmut_mutants"), args, kwargs, self)
		return result 
	
	_remove_runtime_directories.__signature__ = _mutmut_signature(xCleanupService_remove_runtime_directories__mutmut_orig)
	xCleanupService_remove_runtime_directories__mutmut_orig.__name__ = 'xCleanupService_remove_runtime_directories'

	def xCleanupServiceremove_runtime_backing_files__mutmut_orig(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_1(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = None

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_2(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = None
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_3(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(None)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_4(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=None, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_5(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=None, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_6(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=None)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_7(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_8(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_9(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, )

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_10(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=True, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_11(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = None
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_12(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				None,
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_13(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				None,
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_14(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=None,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_15(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_16(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_17(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_18(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"XXxcrun simctl runtime delete allXX",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_19(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"XCRUN SIMCTL RUNTIME DELETE ALL",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_20(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["XXxcrunXX", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_21(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["XCRUN", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_22(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "XXsimctlXX", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_23(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "SIMCTL", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_24(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "XXruntimeXX", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_25(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "RUNTIME", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_26(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "XXdeleteXX", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_27(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "DELETE", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_28(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "XXallXX"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_29(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "ALL"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_30(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=True,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_31(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(None)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_32(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = None
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_33(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(None)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_34(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=None, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_35(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=None, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_36(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=None)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_37(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_38(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_39(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, )

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_40(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=True, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_41(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = None
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_42(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = None
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_43(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(None)
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_44(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(None))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_45(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(None)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_46(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=None, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_47(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=None, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_48(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=None)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_49(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_50(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_51(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, )

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_52(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=True, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_53(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = None
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_54(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(None)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_55(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=None, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_56(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=None, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_57(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=None)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_58(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_59(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_60(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, )

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_61(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=True, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_62(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = None
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_63(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = None
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_64(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted(None)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_65(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} | final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_66(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=None,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_67(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=None,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_68(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=None,
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_69(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_70(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_71(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_72(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=True,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_73(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(None)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_74(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {'XX, XX'.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_75(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(None)

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_76(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(None)

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_77(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = None
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_78(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(None)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_79(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=None, steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_80(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=None, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_81(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, error=None)

	def xCleanupServiceremove_runtime_backing_files__mutmut_82(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(steps=steps, error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_83(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), error=error)

	def xCleanupServiceremove_runtime_backing_files__mutmut_84(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(steps), steps=steps, )

	def xCleanupServiceremove_runtime_backing_files__mutmut_85(self, include_system_runtime_files: bool) -> ActionResult:
		steps: List[StepResult] = []

		runtimes_before, list_step, list_error = self.list_runtimes()
		steps.append(list_step)
		if list_error:
			return ActionResult(commands_ok=False, steps=steps, error=list_error)

		if runtimes_before:
			delete_all_step = self._run_simctl_step(
				"xcrun simctl runtime delete all",
				["xcrun", "simctl", "runtime", "delete", "all"],
				required=False,
			)
			steps.append(delete_all_step)

			runtimes_after_bulk, list_step_after, list_error_after = self.list_runtimes()
			steps.append(list_step_after)
			if list_error_after:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_after)

			remaining = {runtime.identifier for runtime in runtimes_after_bulk}
			if remaining:
				delete_result = self.delete_runtimes(sorted(remaining))
				steps.extend(delete_result.steps)
				if delete_result.error:
					return ActionResult(commands_ok=False, steps=steps, error=delete_result.error)

			runtimes_final, list_step_final, list_error_final = self.list_runtimes()
			steps.append(list_step_final)
			if list_error_final:
				return ActionResult(commands_ok=False, steps=steps, error=list_error_final)

			final_ids = {runtime.identifier for runtime in runtimes_final}
			still_present = sorted({runtime.identifier for runtime in runtimes_before} & final_ids)
			if still_present:
				return ActionResult(
					commands_ok=False,
					steps=steps,
					error=f"Runtime still registered: {', '.join(still_present)}",
				)

		steps.extend(self._unmount_simulator_volumes())

		if include_system_runtime_files:
			steps.extend(self._remove_runtime_directories())

		error = _first_required_error(steps)
		return ActionResult(commands_ok=_commands_ok(None), steps=steps, error=error)
	
	xCleanupServiceremove_runtime_backing_files__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupServiceremove_runtime_backing_files__mutmut_1': xCleanupServiceremove_runtime_backing_files__mutmut_1, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_2': xCleanupServiceremove_runtime_backing_files__mutmut_2, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_3': xCleanupServiceremove_runtime_backing_files__mutmut_3, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_4': xCleanupServiceremove_runtime_backing_files__mutmut_4, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_5': xCleanupServiceremove_runtime_backing_files__mutmut_5, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_6': xCleanupServiceremove_runtime_backing_files__mutmut_6, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_7': xCleanupServiceremove_runtime_backing_files__mutmut_7, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_8': xCleanupServiceremove_runtime_backing_files__mutmut_8, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_9': xCleanupServiceremove_runtime_backing_files__mutmut_9, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_10': xCleanupServiceremove_runtime_backing_files__mutmut_10, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_11': xCleanupServiceremove_runtime_backing_files__mutmut_11, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_12': xCleanupServiceremove_runtime_backing_files__mutmut_12, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_13': xCleanupServiceremove_runtime_backing_files__mutmut_13, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_14': xCleanupServiceremove_runtime_backing_files__mutmut_14, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_15': xCleanupServiceremove_runtime_backing_files__mutmut_15, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_16': xCleanupServiceremove_runtime_backing_files__mutmut_16, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_17': xCleanupServiceremove_runtime_backing_files__mutmut_17, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_18': xCleanupServiceremove_runtime_backing_files__mutmut_18, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_19': xCleanupServiceremove_runtime_backing_files__mutmut_19, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_20': xCleanupServiceremove_runtime_backing_files__mutmut_20, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_21': xCleanupServiceremove_runtime_backing_files__mutmut_21, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_22': xCleanupServiceremove_runtime_backing_files__mutmut_22, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_23': xCleanupServiceremove_runtime_backing_files__mutmut_23, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_24': xCleanupServiceremove_runtime_backing_files__mutmut_24, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_25': xCleanupServiceremove_runtime_backing_files__mutmut_25, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_26': xCleanupServiceremove_runtime_backing_files__mutmut_26, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_27': xCleanupServiceremove_runtime_backing_files__mutmut_27, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_28': xCleanupServiceremove_runtime_backing_files__mutmut_28, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_29': xCleanupServiceremove_runtime_backing_files__mutmut_29, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_30': xCleanupServiceremove_runtime_backing_files__mutmut_30, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_31': xCleanupServiceremove_runtime_backing_files__mutmut_31, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_32': xCleanupServiceremove_runtime_backing_files__mutmut_32, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_33': xCleanupServiceremove_runtime_backing_files__mutmut_33, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_34': xCleanupServiceremove_runtime_backing_files__mutmut_34, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_35': xCleanupServiceremove_runtime_backing_files__mutmut_35, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_36': xCleanupServiceremove_runtime_backing_files__mutmut_36, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_37': xCleanupServiceremove_runtime_backing_files__mutmut_37, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_38': xCleanupServiceremove_runtime_backing_files__mutmut_38, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_39': xCleanupServiceremove_runtime_backing_files__mutmut_39, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_40': xCleanupServiceremove_runtime_backing_files__mutmut_40, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_41': xCleanupServiceremove_runtime_backing_files__mutmut_41, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_42': xCleanupServiceremove_runtime_backing_files__mutmut_42, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_43': xCleanupServiceremove_runtime_backing_files__mutmut_43, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_44': xCleanupServiceremove_runtime_backing_files__mutmut_44, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_45': xCleanupServiceremove_runtime_backing_files__mutmut_45, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_46': xCleanupServiceremove_runtime_backing_files__mutmut_46, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_47': xCleanupServiceremove_runtime_backing_files__mutmut_47, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_48': xCleanupServiceremove_runtime_backing_files__mutmut_48, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_49': xCleanupServiceremove_runtime_backing_files__mutmut_49, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_50': xCleanupServiceremove_runtime_backing_files__mutmut_50, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_51': xCleanupServiceremove_runtime_backing_files__mutmut_51, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_52': xCleanupServiceremove_runtime_backing_files__mutmut_52, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_53': xCleanupServiceremove_runtime_backing_files__mutmut_53, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_54': xCleanupServiceremove_runtime_backing_files__mutmut_54, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_55': xCleanupServiceremove_runtime_backing_files__mutmut_55, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_56': xCleanupServiceremove_runtime_backing_files__mutmut_56, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_57': xCleanupServiceremove_runtime_backing_files__mutmut_57, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_58': xCleanupServiceremove_runtime_backing_files__mutmut_58, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_59': xCleanupServiceremove_runtime_backing_files__mutmut_59, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_60': xCleanupServiceremove_runtime_backing_files__mutmut_60, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_61': xCleanupServiceremove_runtime_backing_files__mutmut_61, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_62': xCleanupServiceremove_runtime_backing_files__mutmut_62, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_63': xCleanupServiceremove_runtime_backing_files__mutmut_63, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_64': xCleanupServiceremove_runtime_backing_files__mutmut_64, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_65': xCleanupServiceremove_runtime_backing_files__mutmut_65, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_66': xCleanupServiceremove_runtime_backing_files__mutmut_66, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_67': xCleanupServiceremove_runtime_backing_files__mutmut_67, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_68': xCleanupServiceremove_runtime_backing_files__mutmut_68, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_69': xCleanupServiceremove_runtime_backing_files__mutmut_69, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_70': xCleanupServiceremove_runtime_backing_files__mutmut_70, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_71': xCleanupServiceremove_runtime_backing_files__mutmut_71, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_72': xCleanupServiceremove_runtime_backing_files__mutmut_72, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_73': xCleanupServiceremove_runtime_backing_files__mutmut_73, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_74': xCleanupServiceremove_runtime_backing_files__mutmut_74, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_75': xCleanupServiceremove_runtime_backing_files__mutmut_75, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_76': xCleanupServiceremove_runtime_backing_files__mutmut_76, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_77': xCleanupServiceremove_runtime_backing_files__mutmut_77, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_78': xCleanupServiceremove_runtime_backing_files__mutmut_78, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_79': xCleanupServiceremove_runtime_backing_files__mutmut_79, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_80': xCleanupServiceremove_runtime_backing_files__mutmut_80, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_81': xCleanupServiceremove_runtime_backing_files__mutmut_81, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_82': xCleanupServiceremove_runtime_backing_files__mutmut_82, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_83': xCleanupServiceremove_runtime_backing_files__mutmut_83, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_84': xCleanupServiceremove_runtime_backing_files__mutmut_84, 
	    'xCleanupServiceremove_runtime_backing_files__mutmut_85': xCleanupServiceremove_runtime_backing_files__mutmut_85
	}
	
	def remove_runtime_backing_files(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupServiceremove_runtime_backing_files__mutmut_orig"), object.__getattribute__(self, "xCleanupServiceremove_runtime_backing_files__mutmut_mutants"), args, kwargs, self)
		return result 
	
	remove_runtime_backing_files.__signature__ = _mutmut_signature(xCleanupServiceremove_runtime_backing_files__mutmut_orig)
	xCleanupServiceremove_runtime_backing_files__mutmut_orig.__name__ = 'xCleanupServiceremove_runtime_backing_files'

	def xCleanupServicemanual_cleanup__mutmut_orig(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_1(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = False,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_2(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = False,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_3(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_4(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = None

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_5(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=None):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_6(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_7(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, ):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_8(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = None
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_9(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(None)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_10(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = "XX XX".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_11(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(None)

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_12(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=None, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_13(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=None, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_14(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=None))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_15(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_16(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_17(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, ))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_18(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=True))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_19(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(None)

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_20(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = None
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_21(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append(None)
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_22(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("XX~/Library/Developer/CoreSimulatorXX")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_23(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/library/developer/coresimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_24(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/LIBRARY/DEVELOPER/CORESIMULATOR")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_25(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append(None)
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_26(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("XX~/Library/Developer/Xcode/DerivedDataXX")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_27(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/library/developer/xcode/deriveddata")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_28(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/LIBRARY/DEVELOPER/XCODE/DERIVEDDATA")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_29(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append(None)
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_30(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("XX~/Library/Developer/Xcode/ArchivesXX")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_31(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/library/developer/xcode/archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_32(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/LIBRARY/DEVELOPER/XCODE/ARCHIVES")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_33(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append(None)
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_34(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("XX~/Library/Developer/Xcode/iOS DeviceSupportXX")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_35(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/library/developer/xcode/ios devicesupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_36(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/LIBRARY/DEVELOPER/XCODE/IOS DEVICESUPPORT")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_37(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				None
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_38(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"XX~/Library/Caches/com.apple.dt.XcodeXX",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_39(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/library/caches/com.apple.dt.xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_40(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/LIBRARY/CACHES/COM.APPLE.DT.XCODE",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_41(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"XX~/Library/Caches/org.swift.swiftpmXX",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_42(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/library/caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_43(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/LIBRARY/CACHES/ORG.SWIFT.SWIFTPM",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_44(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = None
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_45(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(None, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_46(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=None)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_47(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_48(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, )
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_49(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=True)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_50(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(None)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_51(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_52(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = ""
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_53(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = ""
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_54(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None or space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_55(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_56(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_57(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = None
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_58(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after + space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_59(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = None

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_60(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta >= 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_61(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 1

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_62(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = None
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_63(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(None)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_64(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=None,
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_65(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_66(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=None,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_67(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=None,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_68(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_69(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=None,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_70(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=None,
		)

	def xCleanupServicemanual_cleanup__mutmut_71(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_72(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_73(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_74(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_75(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			steps=steps,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_76(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			error=error,
		)

	def xCleanupServicemanual_cleanup__mutmut_77(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			)

	def xCleanupServicemanual_cleanup__mutmut_78(
		self,
		*,
		delete_core_simulator: bool,
		delete_derived_data: bool,
		delete_archives: bool,
		delete_caches: bool,
		delete_device_support: bool,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self._unmount_simulator_volumes())

		paths: List[str] = []
		if delete_core_simulator:
			paths.append("~/Library/Developer/CoreSimulator")
		if delete_derived_data:
			paths.append("~/Library/Developer/Xcode/DerivedData")
		if delete_archives:
			paths.append("~/Library/Developer/Xcode/Archives")
		if delete_device_support:
			paths.append("~/Library/Developer/Xcode/iOS DeviceSupport")
		if delete_caches:
			paths.extend(
				[
					"~/Library/Caches/com.apple.dt.Xcode",
					"~/Library/Caches/org.swift.swiftpm",
				]
			)

		if paths:
			clear_result = self.clear_paths(paths, sudo=False)
			steps.extend(clear_result.steps)

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		error = _first_required_error(steps)
		return CleanupResult(
			commands_ok=_commands_ok(None),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)
	
	xCleanupServicemanual_cleanup__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupServicemanual_cleanup__mutmut_1': xCleanupServicemanual_cleanup__mutmut_1, 
	    'xCleanupServicemanual_cleanup__mutmut_2': xCleanupServicemanual_cleanup__mutmut_2, 
	    'xCleanupServicemanual_cleanup__mutmut_3': xCleanupServicemanual_cleanup__mutmut_3, 
	    'xCleanupServicemanual_cleanup__mutmut_4': xCleanupServicemanual_cleanup__mutmut_4, 
	    'xCleanupServicemanual_cleanup__mutmut_5': xCleanupServicemanual_cleanup__mutmut_5, 
	    'xCleanupServicemanual_cleanup__mutmut_6': xCleanupServicemanual_cleanup__mutmut_6, 
	    'xCleanupServicemanual_cleanup__mutmut_7': xCleanupServicemanual_cleanup__mutmut_7, 
	    'xCleanupServicemanual_cleanup__mutmut_8': xCleanupServicemanual_cleanup__mutmut_8, 
	    'xCleanupServicemanual_cleanup__mutmut_9': xCleanupServicemanual_cleanup__mutmut_9, 
	    'xCleanupServicemanual_cleanup__mutmut_10': xCleanupServicemanual_cleanup__mutmut_10, 
	    'xCleanupServicemanual_cleanup__mutmut_11': xCleanupServicemanual_cleanup__mutmut_11, 
	    'xCleanupServicemanual_cleanup__mutmut_12': xCleanupServicemanual_cleanup__mutmut_12, 
	    'xCleanupServicemanual_cleanup__mutmut_13': xCleanupServicemanual_cleanup__mutmut_13, 
	    'xCleanupServicemanual_cleanup__mutmut_14': xCleanupServicemanual_cleanup__mutmut_14, 
	    'xCleanupServicemanual_cleanup__mutmut_15': xCleanupServicemanual_cleanup__mutmut_15, 
	    'xCleanupServicemanual_cleanup__mutmut_16': xCleanupServicemanual_cleanup__mutmut_16, 
	    'xCleanupServicemanual_cleanup__mutmut_17': xCleanupServicemanual_cleanup__mutmut_17, 
	    'xCleanupServicemanual_cleanup__mutmut_18': xCleanupServicemanual_cleanup__mutmut_18, 
	    'xCleanupServicemanual_cleanup__mutmut_19': xCleanupServicemanual_cleanup__mutmut_19, 
	    'xCleanupServicemanual_cleanup__mutmut_20': xCleanupServicemanual_cleanup__mutmut_20, 
	    'xCleanupServicemanual_cleanup__mutmut_21': xCleanupServicemanual_cleanup__mutmut_21, 
	    'xCleanupServicemanual_cleanup__mutmut_22': xCleanupServicemanual_cleanup__mutmut_22, 
	    'xCleanupServicemanual_cleanup__mutmut_23': xCleanupServicemanual_cleanup__mutmut_23, 
	    'xCleanupServicemanual_cleanup__mutmut_24': xCleanupServicemanual_cleanup__mutmut_24, 
	    'xCleanupServicemanual_cleanup__mutmut_25': xCleanupServicemanual_cleanup__mutmut_25, 
	    'xCleanupServicemanual_cleanup__mutmut_26': xCleanupServicemanual_cleanup__mutmut_26, 
	    'xCleanupServicemanual_cleanup__mutmut_27': xCleanupServicemanual_cleanup__mutmut_27, 
	    'xCleanupServicemanual_cleanup__mutmut_28': xCleanupServicemanual_cleanup__mutmut_28, 
	    'xCleanupServicemanual_cleanup__mutmut_29': xCleanupServicemanual_cleanup__mutmut_29, 
	    'xCleanupServicemanual_cleanup__mutmut_30': xCleanupServicemanual_cleanup__mutmut_30, 
	    'xCleanupServicemanual_cleanup__mutmut_31': xCleanupServicemanual_cleanup__mutmut_31, 
	    'xCleanupServicemanual_cleanup__mutmut_32': xCleanupServicemanual_cleanup__mutmut_32, 
	    'xCleanupServicemanual_cleanup__mutmut_33': xCleanupServicemanual_cleanup__mutmut_33, 
	    'xCleanupServicemanual_cleanup__mutmut_34': xCleanupServicemanual_cleanup__mutmut_34, 
	    'xCleanupServicemanual_cleanup__mutmut_35': xCleanupServicemanual_cleanup__mutmut_35, 
	    'xCleanupServicemanual_cleanup__mutmut_36': xCleanupServicemanual_cleanup__mutmut_36, 
	    'xCleanupServicemanual_cleanup__mutmut_37': xCleanupServicemanual_cleanup__mutmut_37, 
	    'xCleanupServicemanual_cleanup__mutmut_38': xCleanupServicemanual_cleanup__mutmut_38, 
	    'xCleanupServicemanual_cleanup__mutmut_39': xCleanupServicemanual_cleanup__mutmut_39, 
	    'xCleanupServicemanual_cleanup__mutmut_40': xCleanupServicemanual_cleanup__mutmut_40, 
	    'xCleanupServicemanual_cleanup__mutmut_41': xCleanupServicemanual_cleanup__mutmut_41, 
	    'xCleanupServicemanual_cleanup__mutmut_42': xCleanupServicemanual_cleanup__mutmut_42, 
	    'xCleanupServicemanual_cleanup__mutmut_43': xCleanupServicemanual_cleanup__mutmut_43, 
	    'xCleanupServicemanual_cleanup__mutmut_44': xCleanupServicemanual_cleanup__mutmut_44, 
	    'xCleanupServicemanual_cleanup__mutmut_45': xCleanupServicemanual_cleanup__mutmut_45, 
	    'xCleanupServicemanual_cleanup__mutmut_46': xCleanupServicemanual_cleanup__mutmut_46, 
	    'xCleanupServicemanual_cleanup__mutmut_47': xCleanupServicemanual_cleanup__mutmut_47, 
	    'xCleanupServicemanual_cleanup__mutmut_48': xCleanupServicemanual_cleanup__mutmut_48, 
	    'xCleanupServicemanual_cleanup__mutmut_49': xCleanupServicemanual_cleanup__mutmut_49, 
	    'xCleanupServicemanual_cleanup__mutmut_50': xCleanupServicemanual_cleanup__mutmut_50, 
	    'xCleanupServicemanual_cleanup__mutmut_51': xCleanupServicemanual_cleanup__mutmut_51, 
	    'xCleanupServicemanual_cleanup__mutmut_52': xCleanupServicemanual_cleanup__mutmut_52, 
	    'xCleanupServicemanual_cleanup__mutmut_53': xCleanupServicemanual_cleanup__mutmut_53, 
	    'xCleanupServicemanual_cleanup__mutmut_54': xCleanupServicemanual_cleanup__mutmut_54, 
	    'xCleanupServicemanual_cleanup__mutmut_55': xCleanupServicemanual_cleanup__mutmut_55, 
	    'xCleanupServicemanual_cleanup__mutmut_56': xCleanupServicemanual_cleanup__mutmut_56, 
	    'xCleanupServicemanual_cleanup__mutmut_57': xCleanupServicemanual_cleanup__mutmut_57, 
	    'xCleanupServicemanual_cleanup__mutmut_58': xCleanupServicemanual_cleanup__mutmut_58, 
	    'xCleanupServicemanual_cleanup__mutmut_59': xCleanupServicemanual_cleanup__mutmut_59, 
	    'xCleanupServicemanual_cleanup__mutmut_60': xCleanupServicemanual_cleanup__mutmut_60, 
	    'xCleanupServicemanual_cleanup__mutmut_61': xCleanupServicemanual_cleanup__mutmut_61, 
	    'xCleanupServicemanual_cleanup__mutmut_62': xCleanupServicemanual_cleanup__mutmut_62, 
	    'xCleanupServicemanual_cleanup__mutmut_63': xCleanupServicemanual_cleanup__mutmut_63, 
	    'xCleanupServicemanual_cleanup__mutmut_64': xCleanupServicemanual_cleanup__mutmut_64, 
	    'xCleanupServicemanual_cleanup__mutmut_65': xCleanupServicemanual_cleanup__mutmut_65, 
	    'xCleanupServicemanual_cleanup__mutmut_66': xCleanupServicemanual_cleanup__mutmut_66, 
	    'xCleanupServicemanual_cleanup__mutmut_67': xCleanupServicemanual_cleanup__mutmut_67, 
	    'xCleanupServicemanual_cleanup__mutmut_68': xCleanupServicemanual_cleanup__mutmut_68, 
	    'xCleanupServicemanual_cleanup__mutmut_69': xCleanupServicemanual_cleanup__mutmut_69, 
	    'xCleanupServicemanual_cleanup__mutmut_70': xCleanupServicemanual_cleanup__mutmut_70, 
	    'xCleanupServicemanual_cleanup__mutmut_71': xCleanupServicemanual_cleanup__mutmut_71, 
	    'xCleanupServicemanual_cleanup__mutmut_72': xCleanupServicemanual_cleanup__mutmut_72, 
	    'xCleanupServicemanual_cleanup__mutmut_73': xCleanupServicemanual_cleanup__mutmut_73, 
	    'xCleanupServicemanual_cleanup__mutmut_74': xCleanupServicemanual_cleanup__mutmut_74, 
	    'xCleanupServicemanual_cleanup__mutmut_75': xCleanupServicemanual_cleanup__mutmut_75, 
	    'xCleanupServicemanual_cleanup__mutmut_76': xCleanupServicemanual_cleanup__mutmut_76, 
	    'xCleanupServicemanual_cleanup__mutmut_77': xCleanupServicemanual_cleanup__mutmut_77, 
	    'xCleanupServicemanual_cleanup__mutmut_78': xCleanupServicemanual_cleanup__mutmut_78
	}
	
	def manual_cleanup(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupServicemanual_cleanup__mutmut_orig"), object.__getattribute__(self, "xCleanupServicemanual_cleanup__mutmut_mutants"), args, kwargs, self)
		return result 
	
	manual_cleanup.__signature__ = _mutmut_signature(xCleanupServicemanual_cleanup__mutmut_orig)
	xCleanupServicemanual_cleanup__mutmut_orig.__name__ = 'xCleanupServicemanual_cleanup'

	def xCleanupServicefree_runtime_space__mutmut_orig(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_1(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = True,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_2(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = True,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_3(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = True,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_4(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = False,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_5(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = False,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_6(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_7(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = None

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_8(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes or include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_9(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=None):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_10(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_11(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, ):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_12(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = None
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_13(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(None)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_14(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = "XX XX".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_15(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(None)

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_16(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=None, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_17(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=None, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_18(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=None))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_19(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_20(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_21(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, ))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_22(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=True))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_23(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(None)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_24(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = None
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_25(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser(None)
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_26(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("XX~/Library/Developer/CoreSimulator/DevicesXX")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_27(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/library/developer/coresimulator/devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_28(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/LIBRARY/DEVELOPER/CORESIMULATOR/DEVICES")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_29(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					None
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_30(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						None,
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_31(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						None,
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_32(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=None,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_33(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_34(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_35(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_36(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["XXrmXX", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_37(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["RM", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_38(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "XX-rfXX", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_39(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-RF", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_40(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=False,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_41(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = None
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_42(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser(None)
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_43(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("XX~/Library/Developer/Xcode/DerivedDataXX")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_44(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/library/developer/xcode/deriveddata")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_45(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/LIBRARY/DEVELOPER/XCODE/DERIVEDDATA")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_46(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					None
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_47(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						None,
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_48(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						None,
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_49(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=None,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_50(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_51(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_52(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_53(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["XXrmXX", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_54(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["RM", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_55(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "XX-rfXX", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_56(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-RF", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_57(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=False,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_58(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = None
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_59(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=None)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_60(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(None)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_61(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = None
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_62(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = ""
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_63(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = ""

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_64(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_65(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = ""
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_66(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = ""
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_67(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None or space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_68(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_69(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_70(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = None
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_71(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after + space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_72(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = None

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_73(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta >= 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_74(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 1

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_75(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_76(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = None

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_77(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(None)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_78(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=None,
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_79(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_80(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=None,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_81(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=None,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_82(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_83(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=None,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_84(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=None,
		)

	def xCleanupServicefree_runtime_space__mutmut_85(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_86(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_87(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_88(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_89(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			steps=steps,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_90(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			error=error,
		)

	def xCleanupServicefree_runtime_space__mutmut_91(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			)

	def xCleanupServicefree_runtime_space__mutmut_92(
		self,
		include_system_runtime_files: bool,
		admin_password: Optional[str] = None,
		include_user_space: bool = False,
		delete_devices: bool = False,
		delete_derived_data: bool = False,
		stop_processes: bool = True,
		measure_space: bool = True,
	) -> CleanupResult:
		space_before = self._space_snapshot() if measure_space else None
		steps: List[StepResult] = []

		if stop_processes and include_system_runtime_files:
			for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
				label = " ".join(result.cmd)
				steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_unavailable_sim_devices().steps)

		if include_user_space:
			if delete_devices:
				devices_path = os.path.expanduser("~/Library/Developer/CoreSimulator/Devices")
				steps.append(
					self._run_step(
						f"rm -rf {devices_path}",
						["rm", "-rf", devices_path],
						required=True,
					)
				)
			if delete_derived_data:
				derived_path = os.path.expanduser("~/Library/Developer/Xcode/DerivedData")
				steps.append(
					self._run_step(
						f"rm -rf {derived_path}",
						["rm", "-rf", derived_path],
						required=True,
					)
				)

		if include_system_runtime_files:
			runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=include_system_runtime_files)
			steps.extend(runtime_result.steps)
			if runtime_result.error:
				error = runtime_result.error
			else:
				error = None
		else:
			error = None

		space_after = self._space_snapshot() if measure_space else None
		space_delta = None
		space_ok = None
		if space_before is not None and space_after is not None:
			space_delta = space_after - space_before
			space_ok = space_delta > 0

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(None),
			space_before=space_before,
			space_after=space_after,
			space_delta=space_delta,
			space_ok=space_ok,
			steps=steps,
			error=error,
		)
	
	xCleanupServicefree_runtime_space__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupServicefree_runtime_space__mutmut_1': xCleanupServicefree_runtime_space__mutmut_1, 
	    'xCleanupServicefree_runtime_space__mutmut_2': xCleanupServicefree_runtime_space__mutmut_2, 
	    'xCleanupServicefree_runtime_space__mutmut_3': xCleanupServicefree_runtime_space__mutmut_3, 
	    'xCleanupServicefree_runtime_space__mutmut_4': xCleanupServicefree_runtime_space__mutmut_4, 
	    'xCleanupServicefree_runtime_space__mutmut_5': xCleanupServicefree_runtime_space__mutmut_5, 
	    'xCleanupServicefree_runtime_space__mutmut_6': xCleanupServicefree_runtime_space__mutmut_6, 
	    'xCleanupServicefree_runtime_space__mutmut_7': xCleanupServicefree_runtime_space__mutmut_7, 
	    'xCleanupServicefree_runtime_space__mutmut_8': xCleanupServicefree_runtime_space__mutmut_8, 
	    'xCleanupServicefree_runtime_space__mutmut_9': xCleanupServicefree_runtime_space__mutmut_9, 
	    'xCleanupServicefree_runtime_space__mutmut_10': xCleanupServicefree_runtime_space__mutmut_10, 
	    'xCleanupServicefree_runtime_space__mutmut_11': xCleanupServicefree_runtime_space__mutmut_11, 
	    'xCleanupServicefree_runtime_space__mutmut_12': xCleanupServicefree_runtime_space__mutmut_12, 
	    'xCleanupServicefree_runtime_space__mutmut_13': xCleanupServicefree_runtime_space__mutmut_13, 
	    'xCleanupServicefree_runtime_space__mutmut_14': xCleanupServicefree_runtime_space__mutmut_14, 
	    'xCleanupServicefree_runtime_space__mutmut_15': xCleanupServicefree_runtime_space__mutmut_15, 
	    'xCleanupServicefree_runtime_space__mutmut_16': xCleanupServicefree_runtime_space__mutmut_16, 
	    'xCleanupServicefree_runtime_space__mutmut_17': xCleanupServicefree_runtime_space__mutmut_17, 
	    'xCleanupServicefree_runtime_space__mutmut_18': xCleanupServicefree_runtime_space__mutmut_18, 
	    'xCleanupServicefree_runtime_space__mutmut_19': xCleanupServicefree_runtime_space__mutmut_19, 
	    'xCleanupServicefree_runtime_space__mutmut_20': xCleanupServicefree_runtime_space__mutmut_20, 
	    'xCleanupServicefree_runtime_space__mutmut_21': xCleanupServicefree_runtime_space__mutmut_21, 
	    'xCleanupServicefree_runtime_space__mutmut_22': xCleanupServicefree_runtime_space__mutmut_22, 
	    'xCleanupServicefree_runtime_space__mutmut_23': xCleanupServicefree_runtime_space__mutmut_23, 
	    'xCleanupServicefree_runtime_space__mutmut_24': xCleanupServicefree_runtime_space__mutmut_24, 
	    'xCleanupServicefree_runtime_space__mutmut_25': xCleanupServicefree_runtime_space__mutmut_25, 
	    'xCleanupServicefree_runtime_space__mutmut_26': xCleanupServicefree_runtime_space__mutmut_26, 
	    'xCleanupServicefree_runtime_space__mutmut_27': xCleanupServicefree_runtime_space__mutmut_27, 
	    'xCleanupServicefree_runtime_space__mutmut_28': xCleanupServicefree_runtime_space__mutmut_28, 
	    'xCleanupServicefree_runtime_space__mutmut_29': xCleanupServicefree_runtime_space__mutmut_29, 
	    'xCleanupServicefree_runtime_space__mutmut_30': xCleanupServicefree_runtime_space__mutmut_30, 
	    'xCleanupServicefree_runtime_space__mutmut_31': xCleanupServicefree_runtime_space__mutmut_31, 
	    'xCleanupServicefree_runtime_space__mutmut_32': xCleanupServicefree_runtime_space__mutmut_32, 
	    'xCleanupServicefree_runtime_space__mutmut_33': xCleanupServicefree_runtime_space__mutmut_33, 
	    'xCleanupServicefree_runtime_space__mutmut_34': xCleanupServicefree_runtime_space__mutmut_34, 
	    'xCleanupServicefree_runtime_space__mutmut_35': xCleanupServicefree_runtime_space__mutmut_35, 
	    'xCleanupServicefree_runtime_space__mutmut_36': xCleanupServicefree_runtime_space__mutmut_36, 
	    'xCleanupServicefree_runtime_space__mutmut_37': xCleanupServicefree_runtime_space__mutmut_37, 
	    'xCleanupServicefree_runtime_space__mutmut_38': xCleanupServicefree_runtime_space__mutmut_38, 
	    'xCleanupServicefree_runtime_space__mutmut_39': xCleanupServicefree_runtime_space__mutmut_39, 
	    'xCleanupServicefree_runtime_space__mutmut_40': xCleanupServicefree_runtime_space__mutmut_40, 
	    'xCleanupServicefree_runtime_space__mutmut_41': xCleanupServicefree_runtime_space__mutmut_41, 
	    'xCleanupServicefree_runtime_space__mutmut_42': xCleanupServicefree_runtime_space__mutmut_42, 
	    'xCleanupServicefree_runtime_space__mutmut_43': xCleanupServicefree_runtime_space__mutmut_43, 
	    'xCleanupServicefree_runtime_space__mutmut_44': xCleanupServicefree_runtime_space__mutmut_44, 
	    'xCleanupServicefree_runtime_space__mutmut_45': xCleanupServicefree_runtime_space__mutmut_45, 
	    'xCleanupServicefree_runtime_space__mutmut_46': xCleanupServicefree_runtime_space__mutmut_46, 
	    'xCleanupServicefree_runtime_space__mutmut_47': xCleanupServicefree_runtime_space__mutmut_47, 
	    'xCleanupServicefree_runtime_space__mutmut_48': xCleanupServicefree_runtime_space__mutmut_48, 
	    'xCleanupServicefree_runtime_space__mutmut_49': xCleanupServicefree_runtime_space__mutmut_49, 
	    'xCleanupServicefree_runtime_space__mutmut_50': xCleanupServicefree_runtime_space__mutmut_50, 
	    'xCleanupServicefree_runtime_space__mutmut_51': xCleanupServicefree_runtime_space__mutmut_51, 
	    'xCleanupServicefree_runtime_space__mutmut_52': xCleanupServicefree_runtime_space__mutmut_52, 
	    'xCleanupServicefree_runtime_space__mutmut_53': xCleanupServicefree_runtime_space__mutmut_53, 
	    'xCleanupServicefree_runtime_space__mutmut_54': xCleanupServicefree_runtime_space__mutmut_54, 
	    'xCleanupServicefree_runtime_space__mutmut_55': xCleanupServicefree_runtime_space__mutmut_55, 
	    'xCleanupServicefree_runtime_space__mutmut_56': xCleanupServicefree_runtime_space__mutmut_56, 
	    'xCleanupServicefree_runtime_space__mutmut_57': xCleanupServicefree_runtime_space__mutmut_57, 
	    'xCleanupServicefree_runtime_space__mutmut_58': xCleanupServicefree_runtime_space__mutmut_58, 
	    'xCleanupServicefree_runtime_space__mutmut_59': xCleanupServicefree_runtime_space__mutmut_59, 
	    'xCleanupServicefree_runtime_space__mutmut_60': xCleanupServicefree_runtime_space__mutmut_60, 
	    'xCleanupServicefree_runtime_space__mutmut_61': xCleanupServicefree_runtime_space__mutmut_61, 
	    'xCleanupServicefree_runtime_space__mutmut_62': xCleanupServicefree_runtime_space__mutmut_62, 
	    'xCleanupServicefree_runtime_space__mutmut_63': xCleanupServicefree_runtime_space__mutmut_63, 
	    'xCleanupServicefree_runtime_space__mutmut_64': xCleanupServicefree_runtime_space__mutmut_64, 
	    'xCleanupServicefree_runtime_space__mutmut_65': xCleanupServicefree_runtime_space__mutmut_65, 
	    'xCleanupServicefree_runtime_space__mutmut_66': xCleanupServicefree_runtime_space__mutmut_66, 
	    'xCleanupServicefree_runtime_space__mutmut_67': xCleanupServicefree_runtime_space__mutmut_67, 
	    'xCleanupServicefree_runtime_space__mutmut_68': xCleanupServicefree_runtime_space__mutmut_68, 
	    'xCleanupServicefree_runtime_space__mutmut_69': xCleanupServicefree_runtime_space__mutmut_69, 
	    'xCleanupServicefree_runtime_space__mutmut_70': xCleanupServicefree_runtime_space__mutmut_70, 
	    'xCleanupServicefree_runtime_space__mutmut_71': xCleanupServicefree_runtime_space__mutmut_71, 
	    'xCleanupServicefree_runtime_space__mutmut_72': xCleanupServicefree_runtime_space__mutmut_72, 
	    'xCleanupServicefree_runtime_space__mutmut_73': xCleanupServicefree_runtime_space__mutmut_73, 
	    'xCleanupServicefree_runtime_space__mutmut_74': xCleanupServicefree_runtime_space__mutmut_74, 
	    'xCleanupServicefree_runtime_space__mutmut_75': xCleanupServicefree_runtime_space__mutmut_75, 
	    'xCleanupServicefree_runtime_space__mutmut_76': xCleanupServicefree_runtime_space__mutmut_76, 
	    'xCleanupServicefree_runtime_space__mutmut_77': xCleanupServicefree_runtime_space__mutmut_77, 
	    'xCleanupServicefree_runtime_space__mutmut_78': xCleanupServicefree_runtime_space__mutmut_78, 
	    'xCleanupServicefree_runtime_space__mutmut_79': xCleanupServicefree_runtime_space__mutmut_79, 
	    'xCleanupServicefree_runtime_space__mutmut_80': xCleanupServicefree_runtime_space__mutmut_80, 
	    'xCleanupServicefree_runtime_space__mutmut_81': xCleanupServicefree_runtime_space__mutmut_81, 
	    'xCleanupServicefree_runtime_space__mutmut_82': xCleanupServicefree_runtime_space__mutmut_82, 
	    'xCleanupServicefree_runtime_space__mutmut_83': xCleanupServicefree_runtime_space__mutmut_83, 
	    'xCleanupServicefree_runtime_space__mutmut_84': xCleanupServicefree_runtime_space__mutmut_84, 
	    'xCleanupServicefree_runtime_space__mutmut_85': xCleanupServicefree_runtime_space__mutmut_85, 
	    'xCleanupServicefree_runtime_space__mutmut_86': xCleanupServicefree_runtime_space__mutmut_86, 
	    'xCleanupServicefree_runtime_space__mutmut_87': xCleanupServicefree_runtime_space__mutmut_87, 
	    'xCleanupServicefree_runtime_space__mutmut_88': xCleanupServicefree_runtime_space__mutmut_88, 
	    'xCleanupServicefree_runtime_space__mutmut_89': xCleanupServicefree_runtime_space__mutmut_89, 
	    'xCleanupServicefree_runtime_space__mutmut_90': xCleanupServicefree_runtime_space__mutmut_90, 
	    'xCleanupServicefree_runtime_space__mutmut_91': xCleanupServicefree_runtime_space__mutmut_91, 
	    'xCleanupServicefree_runtime_space__mutmut_92': xCleanupServicefree_runtime_space__mutmut_92
	}
	
	def free_runtime_space(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupServicefree_runtime_space__mutmut_orig"), object.__getattribute__(self, "xCleanupServicefree_runtime_space__mutmut_mutants"), args, kwargs, self)
		return result 
	
	free_runtime_space.__signature__ = _mutmut_signature(xCleanupServicefree_runtime_space__mutmut_orig)
	xCleanupServicefree_runtime_space__mutmut_orig.__name__ = 'xCleanupServicefree_runtime_space'

	def xCleanupServicenuclear_cleanup__mutmut_orig(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_1(self) -> CleanupResult:
		steps: List[StepResult] = None

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_2(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=None):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_3(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_4(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, ):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_5(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = None
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_6(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(None)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_7(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = "XX XX".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_8(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(None)

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_9(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=None, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_10(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=None, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_11(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=None))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_12(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_13(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_14(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, ))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_15(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=True))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_16(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(None)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_17(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(None)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_18(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(None)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_19(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(None)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_20(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = None
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_21(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=None)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_22(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=False)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_23(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(None)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_24(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = None

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_25(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_26(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = None

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_27(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(None)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_28(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=None,
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_29(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=None,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_30(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=None,
		)

	def xCleanupServicenuclear_cleanup__mutmut_31(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_32(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_33(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_34(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_ok=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_35(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			steps=steps,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_36(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			error=error,
		)

	def xCleanupServicenuclear_cleanup__mutmut_37(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(steps),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			)

	def xCleanupServicenuclear_cleanup__mutmut_38(self) -> CleanupResult:
		steps: List[StepResult] = []

		for result in svc_processes.kill_all_simulators_and_xcode(password=None, runner=self._runner):
			label = " ".join(result.cmd)
			steps.append(StepResult(label=label, result=result, required=False))

		steps.extend(self.delete_all_sim_devices().steps)
		steps.extend(self.remove_device_directories_and_profiles().steps)
		steps.extend(self.clear_all_simulator_caches().steps)
		steps.extend(self.disable_core_simulator_service().steps)

		runtime_result = self.remove_runtime_backing_files(include_system_runtime_files=True)
		steps.extend(runtime_result.steps)
		error = runtime_result.error

		if not error:
			error = _first_required_error(steps)

		return CleanupResult(
			commands_ok=_commands_ok(None),
			space_before=None,
			space_after=None,
			space_delta=None,
			space_ok=None,
			steps=steps,
			error=error,
		)
	
	xCleanupServicenuclear_cleanup__mutmut_mutants : ClassVar[MutantDict] = {
	'xCleanupServicenuclear_cleanup__mutmut_1': xCleanupServicenuclear_cleanup__mutmut_1, 
	    'xCleanupServicenuclear_cleanup__mutmut_2': xCleanupServicenuclear_cleanup__mutmut_2, 
	    'xCleanupServicenuclear_cleanup__mutmut_3': xCleanupServicenuclear_cleanup__mutmut_3, 
	    'xCleanupServicenuclear_cleanup__mutmut_4': xCleanupServicenuclear_cleanup__mutmut_4, 
	    'xCleanupServicenuclear_cleanup__mutmut_5': xCleanupServicenuclear_cleanup__mutmut_5, 
	    'xCleanupServicenuclear_cleanup__mutmut_6': xCleanupServicenuclear_cleanup__mutmut_6, 
	    'xCleanupServicenuclear_cleanup__mutmut_7': xCleanupServicenuclear_cleanup__mutmut_7, 
	    'xCleanupServicenuclear_cleanup__mutmut_8': xCleanupServicenuclear_cleanup__mutmut_8, 
	    'xCleanupServicenuclear_cleanup__mutmut_9': xCleanupServicenuclear_cleanup__mutmut_9, 
	    'xCleanupServicenuclear_cleanup__mutmut_10': xCleanupServicenuclear_cleanup__mutmut_10, 
	    'xCleanupServicenuclear_cleanup__mutmut_11': xCleanupServicenuclear_cleanup__mutmut_11, 
	    'xCleanupServicenuclear_cleanup__mutmut_12': xCleanupServicenuclear_cleanup__mutmut_12, 
	    'xCleanupServicenuclear_cleanup__mutmut_13': xCleanupServicenuclear_cleanup__mutmut_13, 
	    'xCleanupServicenuclear_cleanup__mutmut_14': xCleanupServicenuclear_cleanup__mutmut_14, 
	    'xCleanupServicenuclear_cleanup__mutmut_15': xCleanupServicenuclear_cleanup__mutmut_15, 
	    'xCleanupServicenuclear_cleanup__mutmut_16': xCleanupServicenuclear_cleanup__mutmut_16, 
	    'xCleanupServicenuclear_cleanup__mutmut_17': xCleanupServicenuclear_cleanup__mutmut_17, 
	    'xCleanupServicenuclear_cleanup__mutmut_18': xCleanupServicenuclear_cleanup__mutmut_18, 
	    'xCleanupServicenuclear_cleanup__mutmut_19': xCleanupServicenuclear_cleanup__mutmut_19, 
	    'xCleanupServicenuclear_cleanup__mutmut_20': xCleanupServicenuclear_cleanup__mutmut_20, 
	    'xCleanupServicenuclear_cleanup__mutmut_21': xCleanupServicenuclear_cleanup__mutmut_21, 
	    'xCleanupServicenuclear_cleanup__mutmut_22': xCleanupServicenuclear_cleanup__mutmut_22, 
	    'xCleanupServicenuclear_cleanup__mutmut_23': xCleanupServicenuclear_cleanup__mutmut_23, 
	    'xCleanupServicenuclear_cleanup__mutmut_24': xCleanupServicenuclear_cleanup__mutmut_24, 
	    'xCleanupServicenuclear_cleanup__mutmut_25': xCleanupServicenuclear_cleanup__mutmut_25, 
	    'xCleanupServicenuclear_cleanup__mutmut_26': xCleanupServicenuclear_cleanup__mutmut_26, 
	    'xCleanupServicenuclear_cleanup__mutmut_27': xCleanupServicenuclear_cleanup__mutmut_27, 
	    'xCleanupServicenuclear_cleanup__mutmut_28': xCleanupServicenuclear_cleanup__mutmut_28, 
	    'xCleanupServicenuclear_cleanup__mutmut_29': xCleanupServicenuclear_cleanup__mutmut_29, 
	    'xCleanupServicenuclear_cleanup__mutmut_30': xCleanupServicenuclear_cleanup__mutmut_30, 
	    'xCleanupServicenuclear_cleanup__mutmut_31': xCleanupServicenuclear_cleanup__mutmut_31, 
	    'xCleanupServicenuclear_cleanup__mutmut_32': xCleanupServicenuclear_cleanup__mutmut_32, 
	    'xCleanupServicenuclear_cleanup__mutmut_33': xCleanupServicenuclear_cleanup__mutmut_33, 
	    'xCleanupServicenuclear_cleanup__mutmut_34': xCleanupServicenuclear_cleanup__mutmut_34, 
	    'xCleanupServicenuclear_cleanup__mutmut_35': xCleanupServicenuclear_cleanup__mutmut_35, 
	    'xCleanupServicenuclear_cleanup__mutmut_36': xCleanupServicenuclear_cleanup__mutmut_36, 
	    'xCleanupServicenuclear_cleanup__mutmut_37': xCleanupServicenuclear_cleanup__mutmut_37, 
	    'xCleanupServicenuclear_cleanup__mutmut_38': xCleanupServicenuclear_cleanup__mutmut_38
	}
	
	def nuclear_cleanup(self, *args, **kwargs):
		result = _mutmut_trampoline(object.__getattribute__(self, "xCleanupServicenuclear_cleanup__mutmut_orig"), object.__getattribute__(self, "xCleanupServicenuclear_cleanup__mutmut_mutants"), args, kwargs, self)
		return result 
	
	nuclear_cleanup.__signature__ = _mutmut_signature(xCleanupServicenuclear_cleanup__mutmut_orig)
	xCleanupServicenuclear_cleanup__mutmut_orig.__name__ = 'xCleanupServicenuclear_cleanup'


def x__default_service__mutmut_orig() -> CleanupService:
	return CleanupService(simctl_env=svc_devtools.get_simctl_env())


def x__default_service__mutmut_1() -> CleanupService:
	return CleanupService(simctl_env=None)

x__default_service__mutmut_mutants : ClassVar[MutantDict] = {
'x__default_service__mutmut_1': x__default_service__mutmut_1
}

def _default_service(*args, **kwargs):
	result = _mutmut_trampoline(x__default_service__mutmut_orig, x__default_service__mutmut_mutants, args, kwargs)
	return result 

_default_service.__signature__ = _mutmut_signature(x__default_service__mutmut_orig)
x__default_service__mutmut_orig.__name__ = 'x__default_service'


def delete_all_sim_devices() -> bool:
	return _default_service().delete_all_sim_devices().commands_ok


def delete_unavailable_sim_devices() -> bool:
	return _default_service().delete_unavailable_sim_devices().commands_ok


def remove_device_directories_and_profiles() -> bool:
	return _default_service().remove_device_directories_and_profiles().commands_ok


def disable_core_simulator_service() -> bool:
	return _default_service().disable_core_simulator_service().commands_ok


def x_clear_all_simulator_caches__mutmut_orig() -> List[Tuple[str, int]]:
	result = _default_service().clear_all_simulator_caches()
	return [(step.label.replace("rm -rf ", ""), step.result.returncode) for step in result.steps]


def x_clear_all_simulator_caches__mutmut_1() -> List[Tuple[str, int]]:
	result = None
	return [(step.label.replace("rm -rf ", ""), step.result.returncode) for step in result.steps]


def x_clear_all_simulator_caches__mutmut_2() -> List[Tuple[str, int]]:
	result = _default_service().clear_all_simulator_caches()
	return [(step.label.replace(None, ""), step.result.returncode) for step in result.steps]


def x_clear_all_simulator_caches__mutmut_3() -> List[Tuple[str, int]]:
	result = _default_service().clear_all_simulator_caches()
	return [(step.label.replace("rm -rf ", None), step.result.returncode) for step in result.steps]


def x_clear_all_simulator_caches__mutmut_4() -> List[Tuple[str, int]]:
	result = _default_service().clear_all_simulator_caches()
	return [(step.label.replace(""), step.result.returncode) for step in result.steps]


def x_clear_all_simulator_caches__mutmut_5() -> List[Tuple[str, int]]:
	result = _default_service().clear_all_simulator_caches()
	return [(step.label.replace("rm -rf ", ), step.result.returncode) for step in result.steps]


def x_clear_all_simulator_caches__mutmut_6() -> List[Tuple[str, int]]:
	result = _default_service().clear_all_simulator_caches()
	return [(step.label.replace("XXrm -rf XX", ""), step.result.returncode) for step in result.steps]


def x_clear_all_simulator_caches__mutmut_7() -> List[Tuple[str, int]]:
	result = _default_service().clear_all_simulator_caches()
	return [(step.label.replace("RM -RF ", ""), step.result.returncode) for step in result.steps]


def x_clear_all_simulator_caches__mutmut_8() -> List[Tuple[str, int]]:
	result = _default_service().clear_all_simulator_caches()
	return [(step.label.replace("rm -rf ", "XXXX"), step.result.returncode) for step in result.steps]

x_clear_all_simulator_caches__mutmut_mutants : ClassVar[MutantDict] = {
'x_clear_all_simulator_caches__mutmut_1': x_clear_all_simulator_caches__mutmut_1, 
    'x_clear_all_simulator_caches__mutmut_2': x_clear_all_simulator_caches__mutmut_2, 
    'x_clear_all_simulator_caches__mutmut_3': x_clear_all_simulator_caches__mutmut_3, 
    'x_clear_all_simulator_caches__mutmut_4': x_clear_all_simulator_caches__mutmut_4, 
    'x_clear_all_simulator_caches__mutmut_5': x_clear_all_simulator_caches__mutmut_5, 
    'x_clear_all_simulator_caches__mutmut_6': x_clear_all_simulator_caches__mutmut_6, 
    'x_clear_all_simulator_caches__mutmut_7': x_clear_all_simulator_caches__mutmut_7, 
    'x_clear_all_simulator_caches__mutmut_8': x_clear_all_simulator_caches__mutmut_8
}

def clear_all_simulator_caches(*args, **kwargs):
	result = _mutmut_trampoline(x_clear_all_simulator_caches__mutmut_orig, x_clear_all_simulator_caches__mutmut_mutants, args, kwargs)
	return result 

clear_all_simulator_caches.__signature__ = _mutmut_signature(x_clear_all_simulator_caches__mutmut_orig)
x_clear_all_simulator_caches__mutmut_orig.__name__ = 'x_clear_all_simulator_caches'


def get_apfs_available_bytes() -> Optional[int]:
	return svc_space.get_apfs_available_bytes()


def x_df_bytes__mutmut_orig(path: str = "/System/Volumes/Data") -> Optional[Dict[str, int]]:
	return svc_space.df_bytes(path=path)


def x_df_bytes__mutmut_1(path: str = "XX/System/Volumes/DataXX") -> Optional[Dict[str, int]]:
	return svc_space.df_bytes(path=path)


def x_df_bytes__mutmut_2(path: str = "/system/volumes/data") -> Optional[Dict[str, int]]:
	return svc_space.df_bytes(path=path)


def x_df_bytes__mutmut_3(path: str = "/SYSTEM/VOLUMES/DATA") -> Optional[Dict[str, int]]:
	return svc_space.df_bytes(path=path)


def x_df_bytes__mutmut_4(path: str = "/System/Volumes/Data") -> Optional[Dict[str, int]]:
	return svc_space.df_bytes(path=None)

x_df_bytes__mutmut_mutants : ClassVar[MutantDict] = {
'x_df_bytes__mutmut_1': x_df_bytes__mutmut_1, 
    'x_df_bytes__mutmut_2': x_df_bytes__mutmut_2, 
    'x_df_bytes__mutmut_3': x_df_bytes__mutmut_3, 
    'x_df_bytes__mutmut_4': x_df_bytes__mutmut_4
}

def df_bytes(*args, **kwargs):
	result = _mutmut_trampoline(x_df_bytes__mutmut_orig, x_df_bytes__mutmut_mutants, args, kwargs)
	return result 

df_bytes.__signature__ = _mutmut_signature(x_df_bytes__mutmut_orig)
x_df_bytes__mutmut_orig.__name__ = 'x_df_bytes'


def x_list_runtimes__mutmut_orig() -> List[Dict[str, str]]:
	service = _default_service()
	runtimes, _, error = service.list_runtimes()
	if error:
		return []
	return [
		{
			"id": runtime.identifier,
			"name": runtime.name,
			"version": runtime.version,
			"build": runtime.build,
			"state": runtime.state,
			"sizeBytes": runtime.size_bytes,
		}
		for runtime in runtimes
	]


def x_list_runtimes__mutmut_1() -> List[Dict[str, str]]:
	service = None
	runtimes, _, error = service.list_runtimes()
	if error:
		return []
	return [
		{
			"id": runtime.identifier,
			"name": runtime.name,
			"version": runtime.version,
			"build": runtime.build,
			"state": runtime.state,
			"sizeBytes": runtime.size_bytes,
		}
		for runtime in runtimes
	]


def x_list_runtimes__mutmut_2() -> List[Dict[str, str]]:
	service = _default_service()
	runtimes, _, error = None
	if error:
		return []
	return [
		{
			"id": runtime.identifier,
			"name": runtime.name,
			"version": runtime.version,
			"build": runtime.build,
			"state": runtime.state,
			"sizeBytes": runtime.size_bytes,
		}
		for runtime in runtimes
	]


def x_list_runtimes__mutmut_3() -> List[Dict[str, str]]:
	service = _default_service()
	runtimes, _, error = service.list_runtimes()
	if error:
		return []
	return [
		{
			"XXidXX": runtime.identifier,
			"name": runtime.name,
			"version": runtime.version,
			"build": runtime.build,
			"state": runtime.state,
			"sizeBytes": runtime.size_bytes,
		}
		for runtime in runtimes
	]


def x_list_runtimes__mutmut_4() -> List[Dict[str, str]]:
	service = _default_service()
	runtimes, _, error = service.list_runtimes()
	if error:
		return []
	return [
		{
			"ID": runtime.identifier,
			"name": runtime.name,
			"version": runtime.version,
			"build": runtime.build,
			"state": runtime.state,
			"sizeBytes": runtime.size_bytes,
		}
		for runtime in runtimes
	]


def x_list_runtimes__mutmut_5() -> List[Dict[str, str]]:
	service = _default_service()
	runtimes, _, error = service.list_runtimes()
	if error:
		return []
	return [
		{
			"id": runtime.identifier,
			"XXnameXX": runtime.name,
			"version": runtime.version,
			"build": runtime.build,
			"state": runtime.state,
			"sizeBytes": runtime.size_bytes,
		}
		for runtime in runtimes
	]


def x_list_runtimes__mutmut_6() -> List[Dict[str, str]]:
	service = _default_service()
	runtimes, _, error = service.list_runtimes()
	if error:
		return []
	return [
		{
			"id": runtime.identifier,
			"NAME": runtime.name,
			"version": runtime.version,
			"build": runtime.build,
			"state": runtime.state,
			"sizeBytes": runtime.size_bytes,
		}
		for runtime in runtimes
	]


def x_list_runtimes__mutmut_7() -> List[Dict[str, str]]:
	service = _default_service()
	runtimes, _, error = service.list_runtimes()
	if error:
		return []
	return [
		{
			"id": runtime.identifier,
			"name": runtime.name,
			"XXversionXX": runtime.version,
			"build": runtime.build,
			"state": runtime.state,
			"sizeBytes": runtime.size_bytes,
		}
		for runtime in runtimes
	]


def x_list_runtimes__mutmut_8() -> List[Dict[str, str]]:
	service = _default_service()
	runtimes, _, error = service.list_runtimes()
	if error:
		return []
	return [
		{
			"id": runtime.identifier,
			"name": runtime.name,
			"VERSION": runtime.version,
			"build": runtime.build,
			"state": runtime.state,
			"sizeBytes": runtime.size_bytes,
		}
		for runtime in runtimes
	]


def x_list_runtimes__mutmut_9() -> List[Dict[str, str]]:
	service = _default_service()
	runtimes, _, error = service.list_runtimes()
	if error:
		return []
	return [
		{
			"id": runtime.identifier,
			"name": runtime.name,
			"version": runtime.version,
			"XXbuildXX": runtime.build,
			"state": runtime.state,
			"sizeBytes": runtime.size_bytes,
		}
		for runtime in runtimes
	]


def x_list_runtimes__mutmut_10() -> List[Dict[str, str]]:
	service = _default_service()
	runtimes, _, error = service.list_runtimes()
	if error:
		return []
	return [
		{
			"id": runtime.identifier,
			"name": runtime.name,
			"version": runtime.version,
			"BUILD": runtime.build,
			"state": runtime.state,
			"sizeBytes": runtime.size_bytes,
		}
		for runtime in runtimes
	]


def x_list_runtimes__mutmut_11() -> List[Dict[str, str]]:
	service = _default_service()
	runtimes, _, error = service.list_runtimes()
	if error:
		return []
	return [
		{
			"id": runtime.identifier,
			"name": runtime.name,
			"version": runtime.version,
			"build": runtime.build,
			"XXstateXX": runtime.state,
			"sizeBytes": runtime.size_bytes,
		}
		for runtime in runtimes
	]


def x_list_runtimes__mutmut_12() -> List[Dict[str, str]]:
	service = _default_service()
	runtimes, _, error = service.list_runtimes()
	if error:
		return []
	return [
		{
			"id": runtime.identifier,
			"name": runtime.name,
			"version": runtime.version,
			"build": runtime.build,
			"STATE": runtime.state,
			"sizeBytes": runtime.size_bytes,
		}
		for runtime in runtimes
	]


def x_list_runtimes__mutmut_13() -> List[Dict[str, str]]:
	service = _default_service()
	runtimes, _, error = service.list_runtimes()
	if error:
		return []
	return [
		{
			"id": runtime.identifier,
			"name": runtime.name,
			"version": runtime.version,
			"build": runtime.build,
			"state": runtime.state,
			"XXsizeBytesXX": runtime.size_bytes,
		}
		for runtime in runtimes
	]


def x_list_runtimes__mutmut_14() -> List[Dict[str, str]]:
	service = _default_service()
	runtimes, _, error = service.list_runtimes()
	if error:
		return []
	return [
		{
			"id": runtime.identifier,
			"name": runtime.name,
			"version": runtime.version,
			"build": runtime.build,
			"state": runtime.state,
			"sizebytes": runtime.size_bytes,
		}
		for runtime in runtimes
	]


def x_list_runtimes__mutmut_15() -> List[Dict[str, str]]:
	service = _default_service()
	runtimes, _, error = service.list_runtimes()
	if error:
		return []
	return [
		{
			"id": runtime.identifier,
			"name": runtime.name,
			"version": runtime.version,
			"build": runtime.build,
			"state": runtime.state,
			"SIZEBYTES": runtime.size_bytes,
		}
		for runtime in runtimes
	]

x_list_runtimes__mutmut_mutants : ClassVar[MutantDict] = {
'x_list_runtimes__mutmut_1': x_list_runtimes__mutmut_1, 
    'x_list_runtimes__mutmut_2': x_list_runtimes__mutmut_2, 
    'x_list_runtimes__mutmut_3': x_list_runtimes__mutmut_3, 
    'x_list_runtimes__mutmut_4': x_list_runtimes__mutmut_4, 
    'x_list_runtimes__mutmut_5': x_list_runtimes__mutmut_5, 
    'x_list_runtimes__mutmut_6': x_list_runtimes__mutmut_6, 
    'x_list_runtimes__mutmut_7': x_list_runtimes__mutmut_7, 
    'x_list_runtimes__mutmut_8': x_list_runtimes__mutmut_8, 
    'x_list_runtimes__mutmut_9': x_list_runtimes__mutmut_9, 
    'x_list_runtimes__mutmut_10': x_list_runtimes__mutmut_10, 
    'x_list_runtimes__mutmut_11': x_list_runtimes__mutmut_11, 
    'x_list_runtimes__mutmut_12': x_list_runtimes__mutmut_12, 
    'x_list_runtimes__mutmut_13': x_list_runtimes__mutmut_13, 
    'x_list_runtimes__mutmut_14': x_list_runtimes__mutmut_14, 
    'x_list_runtimes__mutmut_15': x_list_runtimes__mutmut_15
}

def list_runtimes(*args, **kwargs):
	result = _mutmut_trampoline(x_list_runtimes__mutmut_orig, x_list_runtimes__mutmut_mutants, args, kwargs)
	return result 

list_runtimes.__signature__ = _mutmut_signature(x_list_runtimes__mutmut_orig)
x_list_runtimes__mutmut_orig.__name__ = 'x_list_runtimes'


def x_delete_runtime__mutmut_orig(runtime_id: str) -> Tuple[bool, str]:
	result = _default_service().delete_runtimes([runtime_id])
	if result.commands_ok:
		return True, f"Deleted runtime {runtime_id}"
	return False, result.error or f"Failed to delete {runtime_id}"


def x_delete_runtime__mutmut_1(runtime_id: str) -> Tuple[bool, str]:
	result = None
	if result.commands_ok:
		return True, f"Deleted runtime {runtime_id}"
	return False, result.error or f"Failed to delete {runtime_id}"


def x_delete_runtime__mutmut_2(runtime_id: str) -> Tuple[bool, str]:
	result = _default_service().delete_runtimes(None)
	if result.commands_ok:
		return True, f"Deleted runtime {runtime_id}"
	return False, result.error or f"Failed to delete {runtime_id}"


def x_delete_runtime__mutmut_3(runtime_id: str) -> Tuple[bool, str]:
	result = _default_service().delete_runtimes([runtime_id])
	if result.commands_ok:
		return False, f"Deleted runtime {runtime_id}"
	return False, result.error or f"Failed to delete {runtime_id}"


def x_delete_runtime__mutmut_4(runtime_id: str) -> Tuple[bool, str]:
	result = _default_service().delete_runtimes([runtime_id])
	if result.commands_ok:
		return True, f"Deleted runtime {runtime_id}"
	return True, result.error or f"Failed to delete {runtime_id}"


def x_delete_runtime__mutmut_5(runtime_id: str) -> Tuple[bool, str]:
	result = _default_service().delete_runtimes([runtime_id])
	if result.commands_ok:
		return True, f"Deleted runtime {runtime_id}"
	return False, result.error and f"Failed to delete {runtime_id}"

x_delete_runtime__mutmut_mutants : ClassVar[MutantDict] = {
'x_delete_runtime__mutmut_1': x_delete_runtime__mutmut_1, 
    'x_delete_runtime__mutmut_2': x_delete_runtime__mutmut_2, 
    'x_delete_runtime__mutmut_3': x_delete_runtime__mutmut_3, 
    'x_delete_runtime__mutmut_4': x_delete_runtime__mutmut_4, 
    'x_delete_runtime__mutmut_5': x_delete_runtime__mutmut_5
}

def delete_runtime(*args, **kwargs):
	result = _mutmut_trampoline(x_delete_runtime__mutmut_orig, x_delete_runtime__mutmut_mutants, args, kwargs)
	return result 

delete_runtime.__signature__ = _mutmut_signature(x_delete_runtime__mutmut_orig)
x_delete_runtime__mutmut_orig.__name__ = 'x_delete_runtime'


def x_delete_all_runtimes__mutmut_orig() -> List[Tuple[str, int]]:
	result = _default_service().delete_all_runtimes()
	return [(step.label, step.result.returncode) for step in result.steps]


def x_delete_all_runtimes__mutmut_1() -> List[Tuple[str, int]]:
	result = None
	return [(step.label, step.result.returncode) for step in result.steps]

x_delete_all_runtimes__mutmut_mutants : ClassVar[MutantDict] = {
'x_delete_all_runtimes__mutmut_1': x_delete_all_runtimes__mutmut_1
}

def delete_all_runtimes(*args, **kwargs):
	result = _mutmut_trampoline(x_delete_all_runtimes__mutmut_orig, x_delete_all_runtimes__mutmut_mutants, args, kwargs)
	return result 

delete_all_runtimes.__signature__ = _mutmut_signature(x_delete_all_runtimes__mutmut_orig)
x_delete_all_runtimes__mutmut_orig.__name__ = 'x_delete_all_runtimes'


def x_delete_unavailable_runtimes__mutmut_orig() -> Tuple[bool, str]:
	result = _default_service().delete_unavailable_runtimes()
	if result.commands_ok:
		return True, "Done"
	return False, result.error or "Failed"


def x_delete_unavailable_runtimes__mutmut_1() -> Tuple[bool, str]:
	result = None
	if result.commands_ok:
		return True, "Done"
	return False, result.error or "Failed"


def x_delete_unavailable_runtimes__mutmut_2() -> Tuple[bool, str]:
	result = _default_service().delete_unavailable_runtimes()
	if result.commands_ok:
		return False, "Done"
	return False, result.error or "Failed"


def x_delete_unavailable_runtimes__mutmut_3() -> Tuple[bool, str]:
	result = _default_service().delete_unavailable_runtimes()
	if result.commands_ok:
		return True, "XXDoneXX"
	return False, result.error or "Failed"


def x_delete_unavailable_runtimes__mutmut_4() -> Tuple[bool, str]:
	result = _default_service().delete_unavailable_runtimes()
	if result.commands_ok:
		return True, "done"
	return False, result.error or "Failed"


def x_delete_unavailable_runtimes__mutmut_5() -> Tuple[bool, str]:
	result = _default_service().delete_unavailable_runtimes()
	if result.commands_ok:
		return True, "DONE"
	return False, result.error or "Failed"


def x_delete_unavailable_runtimes__mutmut_6() -> Tuple[bool, str]:
	result = _default_service().delete_unavailable_runtimes()
	if result.commands_ok:
		return True, "Done"
	return True, result.error or "Failed"


def x_delete_unavailable_runtimes__mutmut_7() -> Tuple[bool, str]:
	result = _default_service().delete_unavailable_runtimes()
	if result.commands_ok:
		return True, "Done"
	return False, result.error and "Failed"


def x_delete_unavailable_runtimes__mutmut_8() -> Tuple[bool, str]:
	result = _default_service().delete_unavailable_runtimes()
	if result.commands_ok:
		return True, "Done"
	return False, result.error or "XXFailedXX"


def x_delete_unavailable_runtimes__mutmut_9() -> Tuple[bool, str]:
	result = _default_service().delete_unavailable_runtimes()
	if result.commands_ok:
		return True, "Done"
	return False, result.error or "failed"


def x_delete_unavailable_runtimes__mutmut_10() -> Tuple[bool, str]:
	result = _default_service().delete_unavailable_runtimes()
	if result.commands_ok:
		return True, "Done"
	return False, result.error or "FAILED"

x_delete_unavailable_runtimes__mutmut_mutants : ClassVar[MutantDict] = {
'x_delete_unavailable_runtimes__mutmut_1': x_delete_unavailable_runtimes__mutmut_1, 
    'x_delete_unavailable_runtimes__mutmut_2': x_delete_unavailable_runtimes__mutmut_2, 
    'x_delete_unavailable_runtimes__mutmut_3': x_delete_unavailable_runtimes__mutmut_3, 
    'x_delete_unavailable_runtimes__mutmut_4': x_delete_unavailable_runtimes__mutmut_4, 
    'x_delete_unavailable_runtimes__mutmut_5': x_delete_unavailable_runtimes__mutmut_5, 
    'x_delete_unavailable_runtimes__mutmut_6': x_delete_unavailable_runtimes__mutmut_6, 
    'x_delete_unavailable_runtimes__mutmut_7': x_delete_unavailable_runtimes__mutmut_7, 
    'x_delete_unavailable_runtimes__mutmut_8': x_delete_unavailable_runtimes__mutmut_8, 
    'x_delete_unavailable_runtimes__mutmut_9': x_delete_unavailable_runtimes__mutmut_9, 
    'x_delete_unavailable_runtimes__mutmut_10': x_delete_unavailable_runtimes__mutmut_10
}

def delete_unavailable_runtimes(*args, **kwargs):
	result = _mutmut_trampoline(x_delete_unavailable_runtimes__mutmut_orig, x_delete_unavailable_runtimes__mutmut_mutants, args, kwargs)
	return result 

delete_unavailable_runtimes.__signature__ = _mutmut_signature(x_delete_unavailable_runtimes__mutmut_orig)
x_delete_unavailable_runtimes__mutmut_orig.__name__ = 'x_delete_unavailable_runtimes'


def is_xcode_running() -> bool:
	return _default_service().is_xcode_running()


def get_mounted_simulator_volumes() -> List[str]:
	return _default_service().get_mounted_simulator_volumes()


def x_remove_runtime_backing_files__mutmut_orig(admin_password: Optional[str] = None) -> List[Tuple[str, int]]:
	result = _default_service().remove_runtime_backing_files(include_system_runtime_files=True)
	return [(step.label, step.result.returncode) for step in result.steps]


def x_remove_runtime_backing_files__mutmut_1(admin_password: Optional[str] = None) -> List[Tuple[str, int]]:
	result = None
	return [(step.label, step.result.returncode) for step in result.steps]


def x_remove_runtime_backing_files__mutmut_2(admin_password: Optional[str] = None) -> List[Tuple[str, int]]:
	result = _default_service().remove_runtime_backing_files(include_system_runtime_files=None)
	return [(step.label, step.result.returncode) for step in result.steps]


def x_remove_runtime_backing_files__mutmut_3(admin_password: Optional[str] = None) -> List[Tuple[str, int]]:
	result = _default_service().remove_runtime_backing_files(include_system_runtime_files=False)
	return [(step.label, step.result.returncode) for step in result.steps]

x_remove_runtime_backing_files__mutmut_mutants : ClassVar[MutantDict] = {
'x_remove_runtime_backing_files__mutmut_1': x_remove_runtime_backing_files__mutmut_1, 
    'x_remove_runtime_backing_files__mutmut_2': x_remove_runtime_backing_files__mutmut_2, 
    'x_remove_runtime_backing_files__mutmut_3': x_remove_runtime_backing_files__mutmut_3
}

def remove_runtime_backing_files(*args, **kwargs):
	result = _mutmut_trampoline(x_remove_runtime_backing_files__mutmut_orig, x_remove_runtime_backing_files__mutmut_mutants, args, kwargs)
	return result 

remove_runtime_backing_files.__signature__ = _mutmut_signature(x_remove_runtime_backing_files__mutmut_orig)
x_remove_runtime_backing_files__mutmut_orig.__name__ = 'x_remove_runtime_backing_files'


def x_free_runtime_space__mutmut_orig(
	include_system_runtime_files: bool,
	admin_password: Optional[str] = None,
	include_user_space: bool = False,
	delete_devices: bool = False,
	delete_derived_data: bool = False,
	stop_processes: bool = True,
) -> CleanupResult:
	return _default_service().free_runtime_space(
		include_system_runtime_files=include_system_runtime_files,
		admin_password=admin_password,
		include_user_space=include_user_space,
		delete_devices=delete_devices,
		delete_derived_data=delete_derived_data,
		stop_processes=stop_processes,
	)


def x_free_runtime_space__mutmut_1(
	include_system_runtime_files: bool,
	admin_password: Optional[str] = None,
	include_user_space: bool = True,
	delete_devices: bool = False,
	delete_derived_data: bool = False,
	stop_processes: bool = True,
) -> CleanupResult:
	return _default_service().free_runtime_space(
		include_system_runtime_files=include_system_runtime_files,
		admin_password=admin_password,
		include_user_space=include_user_space,
		delete_devices=delete_devices,
		delete_derived_data=delete_derived_data,
		stop_processes=stop_processes,
	)


def x_free_runtime_space__mutmut_2(
	include_system_runtime_files: bool,
	admin_password: Optional[str] = None,
	include_user_space: bool = False,
	delete_devices: bool = True,
	delete_derived_data: bool = False,
	stop_processes: bool = True,
) -> CleanupResult:
	return _default_service().free_runtime_space(
		include_system_runtime_files=include_system_runtime_files,
		admin_password=admin_password,
		include_user_space=include_user_space,
		delete_devices=delete_devices,
		delete_derived_data=delete_derived_data,
		stop_processes=stop_processes,
	)


def x_free_runtime_space__mutmut_3(
	include_system_runtime_files: bool,
	admin_password: Optional[str] = None,
	include_user_space: bool = False,
	delete_devices: bool = False,
	delete_derived_data: bool = True,
	stop_processes: bool = True,
) -> CleanupResult:
	return _default_service().free_runtime_space(
		include_system_runtime_files=include_system_runtime_files,
		admin_password=admin_password,
		include_user_space=include_user_space,
		delete_devices=delete_devices,
		delete_derived_data=delete_derived_data,
		stop_processes=stop_processes,
	)


def x_free_runtime_space__mutmut_4(
	include_system_runtime_files: bool,
	admin_password: Optional[str] = None,
	include_user_space: bool = False,
	delete_devices: bool = False,
	delete_derived_data: bool = False,
	stop_processes: bool = False,
) -> CleanupResult:
	return _default_service().free_runtime_space(
		include_system_runtime_files=include_system_runtime_files,
		admin_password=admin_password,
		include_user_space=include_user_space,
		delete_devices=delete_devices,
		delete_derived_data=delete_derived_data,
		stop_processes=stop_processes,
	)


def x_free_runtime_space__mutmut_5(
	include_system_runtime_files: bool,
	admin_password: Optional[str] = None,
	include_user_space: bool = False,
	delete_devices: bool = False,
	delete_derived_data: bool = False,
	stop_processes: bool = True,
) -> CleanupResult:
	return _default_service().free_runtime_space(
		include_system_runtime_files=None,
		admin_password=admin_password,
		include_user_space=include_user_space,
		delete_devices=delete_devices,
		delete_derived_data=delete_derived_data,
		stop_processes=stop_processes,
	)


def x_free_runtime_space__mutmut_6(
	include_system_runtime_files: bool,
	admin_password: Optional[str] = None,
	include_user_space: bool = False,
	delete_devices: bool = False,
	delete_derived_data: bool = False,
	stop_processes: bool = True,
) -> CleanupResult:
	return _default_service().free_runtime_space(
		include_system_runtime_files=include_system_runtime_files,
		admin_password=None,
		include_user_space=include_user_space,
		delete_devices=delete_devices,
		delete_derived_data=delete_derived_data,
		stop_processes=stop_processes,
	)


def x_free_runtime_space__mutmut_7(
	include_system_runtime_files: bool,
	admin_password: Optional[str] = None,
	include_user_space: bool = False,
	delete_devices: bool = False,
	delete_derived_data: bool = False,
	stop_processes: bool = True,
) -> CleanupResult:
	return _default_service().free_runtime_space(
		include_system_runtime_files=include_system_runtime_files,
		admin_password=admin_password,
		include_user_space=None,
		delete_devices=delete_devices,
		delete_derived_data=delete_derived_data,
		stop_processes=stop_processes,
	)


def x_free_runtime_space__mutmut_8(
	include_system_runtime_files: bool,
	admin_password: Optional[str] = None,
	include_user_space: bool = False,
	delete_devices: bool = False,
	delete_derived_data: bool = False,
	stop_processes: bool = True,
) -> CleanupResult:
	return _default_service().free_runtime_space(
		include_system_runtime_files=include_system_runtime_files,
		admin_password=admin_password,
		include_user_space=include_user_space,
		delete_devices=None,
		delete_derived_data=delete_derived_data,
		stop_processes=stop_processes,
	)


def x_free_runtime_space__mutmut_9(
	include_system_runtime_files: bool,
	admin_password: Optional[str] = None,
	include_user_space: bool = False,
	delete_devices: bool = False,
	delete_derived_data: bool = False,
	stop_processes: bool = True,
) -> CleanupResult:
	return _default_service().free_runtime_space(
		include_system_runtime_files=include_system_runtime_files,
		admin_password=admin_password,
		include_user_space=include_user_space,
		delete_devices=delete_devices,
		delete_derived_data=None,
		stop_processes=stop_processes,
	)


def x_free_runtime_space__mutmut_10(
	include_system_runtime_files: bool,
	admin_password: Optional[str] = None,
	include_user_space: bool = False,
	delete_devices: bool = False,
	delete_derived_data: bool = False,
	stop_processes: bool = True,
) -> CleanupResult:
	return _default_service().free_runtime_space(
		include_system_runtime_files=include_system_runtime_files,
		admin_password=admin_password,
		include_user_space=include_user_space,
		delete_devices=delete_devices,
		delete_derived_data=delete_derived_data,
		stop_processes=None,
	)


def x_free_runtime_space__mutmut_11(
	include_system_runtime_files: bool,
	admin_password: Optional[str] = None,
	include_user_space: bool = False,
	delete_devices: bool = False,
	delete_derived_data: bool = False,
	stop_processes: bool = True,
) -> CleanupResult:
	return _default_service().free_runtime_space(
		admin_password=admin_password,
		include_user_space=include_user_space,
		delete_devices=delete_devices,
		delete_derived_data=delete_derived_data,
		stop_processes=stop_processes,
	)


def x_free_runtime_space__mutmut_12(
	include_system_runtime_files: bool,
	admin_password: Optional[str] = None,
	include_user_space: bool = False,
	delete_devices: bool = False,
	delete_derived_data: bool = False,
	stop_processes: bool = True,
) -> CleanupResult:
	return _default_service().free_runtime_space(
		include_system_runtime_files=include_system_runtime_files,
		include_user_space=include_user_space,
		delete_devices=delete_devices,
		delete_derived_data=delete_derived_data,
		stop_processes=stop_processes,
	)


def x_free_runtime_space__mutmut_13(
	include_system_runtime_files: bool,
	admin_password: Optional[str] = None,
	include_user_space: bool = False,
	delete_devices: bool = False,
	delete_derived_data: bool = False,
	stop_processes: bool = True,
) -> CleanupResult:
	return _default_service().free_runtime_space(
		include_system_runtime_files=include_system_runtime_files,
		admin_password=admin_password,
		delete_devices=delete_devices,
		delete_derived_data=delete_derived_data,
		stop_processes=stop_processes,
	)


def x_free_runtime_space__mutmut_14(
	include_system_runtime_files: bool,
	admin_password: Optional[str] = None,
	include_user_space: bool = False,
	delete_devices: bool = False,
	delete_derived_data: bool = False,
	stop_processes: bool = True,
) -> CleanupResult:
	return _default_service().free_runtime_space(
		include_system_runtime_files=include_system_runtime_files,
		admin_password=admin_password,
		include_user_space=include_user_space,
		delete_derived_data=delete_derived_data,
		stop_processes=stop_processes,
	)


def x_free_runtime_space__mutmut_15(
	include_system_runtime_files: bool,
	admin_password: Optional[str] = None,
	include_user_space: bool = False,
	delete_devices: bool = False,
	delete_derived_data: bool = False,
	stop_processes: bool = True,
) -> CleanupResult:
	return _default_service().free_runtime_space(
		include_system_runtime_files=include_system_runtime_files,
		admin_password=admin_password,
		include_user_space=include_user_space,
		delete_devices=delete_devices,
		stop_processes=stop_processes,
	)


def x_free_runtime_space__mutmut_16(
	include_system_runtime_files: bool,
	admin_password: Optional[str] = None,
	include_user_space: bool = False,
	delete_devices: bool = False,
	delete_derived_data: bool = False,
	stop_processes: bool = True,
) -> CleanupResult:
	return _default_service().free_runtime_space(
		include_system_runtime_files=include_system_runtime_files,
		admin_password=admin_password,
		include_user_space=include_user_space,
		delete_devices=delete_devices,
		delete_derived_data=delete_derived_data,
		)

x_free_runtime_space__mutmut_mutants : ClassVar[MutantDict] = {
'x_free_runtime_space__mutmut_1': x_free_runtime_space__mutmut_1, 
    'x_free_runtime_space__mutmut_2': x_free_runtime_space__mutmut_2, 
    'x_free_runtime_space__mutmut_3': x_free_runtime_space__mutmut_3, 
    'x_free_runtime_space__mutmut_4': x_free_runtime_space__mutmut_4, 
    'x_free_runtime_space__mutmut_5': x_free_runtime_space__mutmut_5, 
    'x_free_runtime_space__mutmut_6': x_free_runtime_space__mutmut_6, 
    'x_free_runtime_space__mutmut_7': x_free_runtime_space__mutmut_7, 
    'x_free_runtime_space__mutmut_8': x_free_runtime_space__mutmut_8, 
    'x_free_runtime_space__mutmut_9': x_free_runtime_space__mutmut_9, 
    'x_free_runtime_space__mutmut_10': x_free_runtime_space__mutmut_10, 
    'x_free_runtime_space__mutmut_11': x_free_runtime_space__mutmut_11, 
    'x_free_runtime_space__mutmut_12': x_free_runtime_space__mutmut_12, 
    'x_free_runtime_space__mutmut_13': x_free_runtime_space__mutmut_13, 
    'x_free_runtime_space__mutmut_14': x_free_runtime_space__mutmut_14, 
    'x_free_runtime_space__mutmut_15': x_free_runtime_space__mutmut_15, 
    'x_free_runtime_space__mutmut_16': x_free_runtime_space__mutmut_16
}

def free_runtime_space(*args, **kwargs):
	result = _mutmut_trampoline(x_free_runtime_space__mutmut_orig, x_free_runtime_space__mutmut_mutants, args, kwargs)
	return result 

free_runtime_space.__signature__ = _mutmut_signature(x_free_runtime_space__mutmut_orig)
x_free_runtime_space__mutmut_orig.__name__ = 'x_free_runtime_space'


def nuclear_cleanup() -> CleanupResult:
	return _default_service().nuclear_cleanup()
